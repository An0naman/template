<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Serial Plotter</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
    <style>
        body { padding: 20px; background-color: #f8f9fa; }
        .chart-container { position: relative; height: 60vh; width: 100%; }
        .card { box-shadow: 0 0.15rem 1.75rem 0 rgba(58, 59, 69, 0.15); border: none; }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h3><i class="fas fa-chart-line me-2"></i>Sensor Serial Plotter: <span id="sensorIdDisplay" class="text-primary">Loading...</span></h3>
            <div>
                <button class="btn btn-outline-secondary btn-sm" onclick="togglePause()" id="pauseBtn">
                    <i class="fas fa-pause"></i> Pause
                </button>
                <button class="btn btn-outline-danger btn-sm" onclick="clearData()">
                    <i class="fas fa-trash"></i> Clear
                </button>
                <a href="/manage-sensors" class="btn btn-outline-primary btn-sm">Back to Sensors</a>
            </div>
        </div>
        
        <div class="card mb-4">
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="sensorChart"></canvas>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-header py-3">
                        <h6 class="m-0 font-weight-bold text-primary">Latest Data Packet</h6>
                    </div>
                    <div class="card-body">
                        <pre id="latestData" class="bg-light p-3 border rounded mb-0" style="max-height: 200px; overflow-y: auto;">Waiting for data...</pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const sensorId = urlParams.get('sensor_id');
        document.getElementById('sensorIdDisplay').textContent = sensorId || 'Unknown';

        let isPaused = false;
        let chart;
        
        // Configuration
        const MAX_POINTS = 100; // Maximum points to show on chart

        function initChart() {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'second',
                                displayFormats: {
                                    second: 'HH:mm:ss'
                                },
                                tooltipFormat: 'HH:mm:ss.SSS'
                            },
                            title: { display: true, text: 'Time' },
                            grid: { display: false }
                        },
                        y: {
                            title: { display: true, text: 'Value' },
                            grid: { borderDash: [2, 2] }
                        }
                    },
                    animation: false,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    plugins: {
                        legend: { position: 'top' },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
        }

        async function fetchData() {
            if (isPaused || !sensorId) return;

            try {
                const response = await fetch(`/api/sensor-master/telemetry/${sensorId}?limit=${MAX_POINTS}`);
                if (!response.ok) throw new Error('Network response was not ok');
                
                const data = await response.json();

                if (data.telemetry && data.telemetry.length > 0) {
                    updateChart(data.telemetry);
                    document.getElementById('latestData').textContent = JSON.stringify(data.telemetry[0].data, null, 2);
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        function updateChart(telemetryData) {
            // Reverse to have oldest first for plotting
            const sortedData = [...telemetryData].reverse();
            
            // Identify all unique keys in the data metrics (excluding non-numeric if needed, but let's keep all)
            const keys = new Set();
            sortedData.forEach(item => {
                if (item.data && typeof item.data === 'object') {
                    Object.keys(item.data).forEach(key => {
                        if (typeof item.data[key] === 'number') {
                            keys.add(key);
                        }
                    });
                }
            });

            // Remove datasets that are no longer present
            chart.data.datasets = chart.data.datasets.filter(d => keys.has(d.label));

            // Create datasets if they don't exist
            keys.forEach((key, index) => {
                let dataset = chart.data.datasets.find(d => d.label === key);
                if (!dataset) {
                    const color = getColor(index);
                    dataset = {
                        label: key,
                        data: [],
                        borderColor: color,
                        backgroundColor: color,
                        borderWidth: 2,
                        pointRadius: 0, // Hide points for cleaner line
                        pointHoverRadius: 4,
                        tension: 0.2,
                        fill: false
                    };
                    chart.data.datasets.push(dataset);
                }
            });

            // Update data for each dataset
            chart.data.datasets.forEach(dataset => {
                dataset.data = sortedData.map(item => ({
                    x: item.timestamp,
                    y: item.data[dataset.label]
                })).filter(p => p.y !== undefined);
            });

            chart.update('none'); // Update without animation for performance
        }

        function getColor(index) {
            const colors = [
                '#4e73df', '#1cc88a', '#36b9cc', '#f6c23e', '#e74a3b',
                '#858796', '#5a5c69', '#6f42c1', '#fd7e14', '#20c997'
            ];
            return colors[index % colors.length];
        }

        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            if (isPaused) {
                btn.innerHTML = '<i class="fas fa-play"></i> Resume';
                btn.classList.remove('btn-outline-secondary');
                btn.classList.add('btn-outline-success');
            } else {
                btn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                btn.classList.remove('btn-outline-success');
                btn.classList.add('btn-outline-secondary');
            }
        }
        
        function clearData() {
            if(confirm('Clear chart?')) {
                chart.data.datasets.forEach(ds => ds.data = []);
                chart.update();
            }
        }

        if (sensorId) {
            initChart();
            fetchData();
            setInterval(fetchData, 1000); // Poll every 1 second
        } else {
            document.getElementById('sensorIdDisplay').textContent = 'No Sensor ID Provided';
            alert('No sensor ID provided! Please access this page with ?sensor_id=YOUR_SENSOR_ID');
        }
    </script>
</body>
</html>
