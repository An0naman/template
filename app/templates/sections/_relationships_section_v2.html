{# Relationships Section for Entry Detail V2 - Updated: 2025-11-02 - Hierarchy by Relationship Type #}

<div class="relationships-section" id="relationshipsSection{{ entry.id }}">
  
  <!-- Section Header -->
  <div class="section-header mb-3 d-flex justify-content-between align-items-center">
    <h5 class="mb-0">
      <i class="fas fa-link me-2"></i>
      Related Records
    </h5>
    <button id="toggleEmptyRelationships{{ entry.id }}" 
            class="btn btn-sm btn-outline-secondary" 
            onclick="toggleEmptyRelationships{{ entry.id }}()"
            title="Show/hide relationship types with no records"
            style="display: none;">
      <i class="fas fa-eye me-1"></i>
      <span class="toggle-text">Show Empty</span>
    </button>
  </div>

  <!-- Loading State -->
  <div id="relationshipsLoading{{ entry.id }}" class="text-center py-4">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2 text-muted">Loading relationships...</p>
  </div>

  <!-- Section Content -->
  <div id="relatedRecordsContainer{{ entry.id }}" style="display: none;">
    
    <!-- Tabs Navigation -->
    <ul class="nav nav-tabs mb-3" id="relationshipsTabs{{ entry.id }}" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="groupedTab{{ entry.id }}-tab" data-bs-toggle="tab" 
                data-bs-target="#groupedTab{{ entry.id }}" type="button" role="tab" 
                aria-controls="groupedTab{{ entry.id }}" aria-selected="true">
          <i class="fas fa-th-list me-1"></i> Grouped View
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="hierarchyTab{{ entry.id }}-tab" data-bs-toggle="tab" 
                data-bs-target="#hierarchyTab{{ entry.id }}" type="button" role="tab" 
                aria-controls="hierarchyTab{{ entry.id }}" aria-selected="false">
          <i class="fas fa-sitemap me-1"></i> Hierarchy View
        </button>
      </li>
    </ul>
    
    <!-- Tab Content -->
    <div class="tab-content" id="relationshipsTabContent{{ entry.id }}">
      
      <!-- Grouped View Tab (default) -->
      <div class="tab-pane fade show active" id="groupedTab{{ entry.id }}" role="tabpanel" 
           aria-labelledby="groupedTab{{ entry.id }}-tab">
        <div id="groupedViewContainer{{ entry.id }}">
          <!-- Will be populated via JavaScript with cards for each relationship type -->
        </div>
      </div>
      
      <!-- Hierarchy View Tab -->
      <div class="tab-pane fade" id="hierarchyTab{{ entry.id }}" role="tabpanel" 
           aria-labelledby="hierarchyTab{{ entry.id }}-tab">
        
        <div id="hierarchyLoading{{ entry.id }}" class="text-center py-4" style="display: none;">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2 text-muted">Loading hierarchy...</p>
        </div>
        
        <div id="hierarchyContent{{ entry.id }}">
          <!-- Will be populated via JavaScript when tab is activated -->
        </div>
      </div>
      
    </div>
  </div>

</div>

<style>
/* Relationship cards styling with theme support */
.relationship-type-card {
    margin-bottom: 1rem;
    border: 1px solid var(--theme-border-color, var(--bs-border-color));
    border-radius: 0.5rem;
    overflow: visible; /* Changed from hidden to allow dropdown menus to overflow */
    background-color: var(--theme-card-bg, var(--bs-body-bg));
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease, transform 0.2s ease, opacity 0.3s ease, max-height 0.3s ease;
}

/* Empty relationship cards - hidden by default */
.empty-relationship-card {
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    margin-bottom: 0;
    transition: opacity 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
}

/* Visual distinction for empty cards when shown */
.empty-relationship-card .card-header {
    background-color: var(--bs-light);
    opacity: 0.85;
}

.empty-relationship-card .card-body {
    background-color: var(--bs-light);
}

[data-bs-theme="dark"] .empty-relationship-card .card-header,
[data-bs-theme="dark"] .empty-relationship-card .card-body {
    background-color: var(--bs-dark);
}

.relationship-type-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
}

.relationship-type-card .card-header {
    background-color: var(--bs-secondary-bg);
    border-bottom: 1px solid var(--bs-border-color);
    padding: 0.75rem 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    overflow: visible; /* Allow dropdown menus to overflow */
}

.relationship-type-card .card-header h6 {
    margin: 0;
    font-weight: 600;
    color: var(--bs-body-color);
}

.relationship-type-card .card-body {
    padding: 0;
    background-color: var(--theme-card-body-bg, var(--bs-body-bg));
}

.relationship-type-card table {
    margin: 0;
}

.relationship-type-card .table > :not(caption) > * > * {
    padding: 0.5rem 1rem;
    border-color: var(--theme-border-color, var(--bs-border-color));
}

.relationship-item-row {
    transition: background-color 0.15s ease;
}

.relationship-item-row:hover {
    background-color: var(--theme-hover-bg, var(--bs-secondary-bg));
}

.relationship-link {
    color: var(--bs-body-color) !important;
    text-decoration: none;
    transition: opacity 0.2s ease;
}

.relationship-link:hover {
    opacity: 0.7;
    text-decoration: underline;
}

.btn-add-relationship {
    white-space: nowrap;
    transition: all 0.2s ease;
}

.btn-add-relationship:hover:not(:disabled) {
    transform: scale(1.05);
}

.btn-add-relationship:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Dark mode adjustments */
[data-bs-theme="dark"] .relationship-type-card {
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

[data-bs-theme="dark"] .relationship-type-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

/* Empty state styling */
.relationships-empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--bs-secondary-color);
}

.relationships-empty-state i {
    font-size: 3rem;
    opacity: 0.25;
    margin-bottom: 1rem;
}

/* Multi-select dropdown styling - makes it look like regular dropdown when closed */
.relationship-state-filter[multiple] {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 16px 12px;
    padding-right: 2.25rem;
    overflow-y: auto;
}

[data-bs-theme="dark"] .relationship-state-filter[multiple] {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23dee2e6' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
}

/* When focused/opened, expand to show all options (or max 400px) */
.relationship-state-filter[multiple]:focus {
    height: auto !important;
    max-height: 400px;
    min-height: 31px;
}

/* Ensure card header allows dropdown to overflow */
.relationship-type-card .card-header {
    position: relative;
    z-index: 10;
}

/* Hierarchy Tree Styles */
.relationship-tree {
    padding: 1rem 0;
}

.tree-node {
    margin-bottom: 0.25rem;
}

.tree-node-content {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    border-radius: 0.25rem;
    transition: background-color 0.15s ease;
}

.tree-node-content:hover {
    background-color: var(--theme-hover-bg, var(--bs-secondary-bg));
}

.tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.1);
    border-left: 3px solid #0d6efd;
}

[data-bs-theme="dark"] .tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.2);
}

.tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.1);
    border-left: 3px solid #0dcaf0;
}

[data-bs-theme="dark"] .tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.15);
}

.tree-toggle-btn {
    background: none;
    border: none;
    padding: 0.25rem;
    margin-right: 0.5rem;
    cursor: pointer;
    color: var(--bs-secondary);
    transition: transform 0.2s ease, color 0.2s ease;
    width: 20px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.tree-toggle-btn:hover {
    color: var(--bs-primary);
}

.tree-toggle-btn i {
    transition: transform 0.2s ease;
}

.tree-spacer {
    display: inline-block;
    width: 20px;
    margin-right: 0.5rem;
}

.tree-entry-type {
    margin-right: 0.5rem;
    font-size: 1rem;
}

.tree-direction-icon {
    margin-right: 0.5rem;
    font-size: 0.875rem;
    display: inline-flex;
    align-items: center;
}

.tree-direction-icon i {
    font-size: 0.75rem;
}

.tree-entry-link {
    color: var(--bs-body-color);
    text-decoration: none;
    margin-right: 0.5rem;
    transition: color 0.2s ease;
}

.tree-entry-link:hover {
    color: var(--bs-primary);
    text-decoration: underline;
}

.tree-children {
    overflow: hidden;
    max-height: 5000px;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    opacity: 1;
}

.tree-children.collapsed {
    max-height: 0;
    opacity: 0;
}

.status-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    background-color: var(--bs-secondary);
    color: white;
}

/* Empty state for hierarchy */
.hierarchy-empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--bs-secondary-color);
}

.hierarchy-empty-state i {
    font-size: 3rem;
    opacity: 0.25;
    margin-bottom: 1rem;
    display: block;
}

/* Tabs styling */
.nav-tabs {
    border-bottom: 2px solid var(--bs-border-color);
}

.nav-tabs .nav-link {
    color: var(--bs-secondary-color);
    border: none;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
}

.nav-tabs .nav-link:hover {
    color: var(--bs-body-color);
    border-bottom-color: var(--bs-secondary);
}

.nav-tabs .nav-link.active {
    color: var(--bs-primary);
    background-color: transparent;
    border-bottom-color: var(--bs-primary);
}
</style>

<script>
// Version: 2025-11-02-20:20 - Hierarchy by Relationship Type with Full Descendants
(function() {
    const entryId = {{ entry.id }};
    const currentEntryTypeId = {{ entry.entry_type_id }};
    
    console.log('=== Relationships Section V2 Loaded - Version 2025-11-02-20:20 ===');
    
    // Store definitions globally for this entry
    let relationshipDefinitions = [];
    
    async function loadRelationships() {
        const loadingEl = document.getElementById('relationshipsLoading' + entryId);
        const containerEl = document.getElementById('relatedRecordsContainer' + entryId);
        
        try {
            // Fetch relationship definitions
            const defsResponse = await fetch('/api/relationship_definitions');
            const definitions = await defsResponse.json();
            
            // Filter to relevant definitions for this entry type
            relationshipDefinitions = definitions.filter(def => 
                def.entry_type_id_from === currentEntryTypeId || 
                def.entry_type_id_to === currentEntryTypeId
            );
            
            // Fetch existing relationships
            const relsResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relsResponse.json();
            
            // Group relationships by definition ID
            const groupedRelationships = {};
            relationships.forEach(rel => {
                if (!groupedRelationships[rel.definition_id]) {
                    groupedRelationships[rel.definition_id] = [];
                }
                groupedRelationships[rel.definition_id].push(rel);
            });
            
            // Render the cards
            renderRelationshipCards(relationshipDefinitions, groupedRelationships);
            
            loadingEl.style.display = 'none';
            containerEl.style.display = 'block';
            
        } catch (error) {
            console.error('Error loading relationships:', error);
            loadingEl.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading relationships: ${error.message}
                </div>
            `;
        }
    }
    
    function renderRelationshipCards(definitions, groupedRelationships) {
        const container = document.getElementById('groupedViewContainer' + entryId);
        
        if (!container) {
            console.error('Grouped view container not found');
            return;
        }
        
        if (definitions.length === 0) {
            container.innerHTML = `
                <div class="relationships-empty-state">
                    <i class="fas fa-link"></i>
                    <p>No relationship types available for this entry type.</p>
                </div>
            `;
            return;
        }
        
        let html = '';
        let hasEmptyCards = false;
        
        definitions.forEach(def => {
            const isFromSide = def.entry_type_id_from === currentEntryTypeId;
            const relationships = groupedRelationships[def.id] || [];
            
            // Determine the appropriate label and cardinality
            const displayLabel = isFromSide ? def.label_from_side : def.label_to_side;
            const relevantCardinality = isFromSide ? def.cardinality_from : def.cardinality_to;
            const canAddMore = relevantCardinality === -1 || relationships.length < relevantCardinality;
            
            // Check if this card is empty
            const isEmpty = relationships.length === 0;
            if (isEmpty) hasEmptyCards = true;
            
            html += `
                <div class="relationship-type-card ${isEmpty ? 'empty-relationship-card' : ''}" 
                     data-definition-id="${def.id}"
                     style="${isEmpty ? 'display: none;' : ''}">
                    <div class="card-header">
                        <h6>${escapeHtml(displayLabel || def.name)}</h6>
                        <div class="d-flex gap-2 align-items-center flex-wrap">
                            <select class="form-select form-select-sm relationship-state-filter" 
                                    data-definition-id="${def.id}"
                                    multiple
                                    style="width: auto; min-width: 180px; height: 31px;"
                                    title="Filter by status (Ctrl+Click for multiple)">
                                <option value="">All Status</option>
                                <option value="active">✓ Active (Ongoing)</option>
                                <option value="inactive">✕ Inactive (Completed)</option>
                                <optgroup label="Specific Status">
                                    <!-- Will be populated dynamically -->
                                </optgroup>
                            </select>
                            <button class="btn btn-sm btn-outline-secondary btn-save-filter" 
                                    data-definition-id="${def.id}"
                                    title="Save current filter as default for this relationship type">
                                <i class="fas fa-save"></i>
                            </button>
                            <button class="btn btn-sm btn-primary btn-add-relationship" 
                                    data-definition-id="${def.id}"
                                    data-label="${escapeHtml(displayLabel || def.name)}"
                                    data-target-type-id="${isFromSide ? def.entry_type_id_to : def.entry_type_id_from}"
                                    data-target-type-label="${isFromSide ? def.entry_type_to_label : def.entry_type_from_label}"
                                    data-allow-quantity="${def.allow_quantity_unit}"
                                    ${!canAddMore ? 'disabled' : ''}
                                    title="${canAddMore ? 'Add ' + (displayLabel || def.name) : 'Maximum entries reached'}">
                                <i class="fas fa-plus me-1"></i>Add
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        ${relationships.length > 0 ? `
                            <table class="table table-sm table-hover mb-0">
                                <tbody>
                                    ${relationships.map(rel => renderRelationshipRow(rel, def)).join('')}
                                </tbody>
                            </table>
                        ` : `
                            <div class="text-center py-3 text-muted">
                                <small>No relationships yet. Click "Add" to create one.</small>
                            </div>
                        `}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        
        // Show/hide the toggle button based on whether there are empty cards
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + entryId);
        if (toggleBtn) {
            toggleBtn.style.display = hasEmptyCards ? 'inline-block' : 'none';
        }
        
        // Attach event listeners
        attachEventListeners();
        
        // Load states for each relationship definition's filter dropdown
        definitions.forEach(def => {
            loadStatesForDefinition(def.id);
        });
        
        // Load and apply saved filter preferences
        loadFilterPreferences();
    }
    
    function renderRelationshipRow(rel, def) {
        // Get contrasting text color for status badge
        const getContrastColor = (hexColor) => {
            if (!hexColor) return '#fff';
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5 ? '#000' : '#fff';
        };
        
        const statusColor = rel.related_entry_status_color || '#6c757d';
        const textColor = getContrastColor(statusColor);
        // Determine status category - we'll need to get this from the API or infer it
        const statusCategory = rel.related_entry_status_category || 'active'; // Default to active if not provided
        const statusName = rel.related_entry_status || '';
        
        return `
            <tr class="relationship-item-row" 
                data-status-category="${statusCategory}" 
                data-status="${statusName.toLowerCase()}">
                <td>
                    <a href="/entry/${rel.related_entry_id}" class="relationship-link">
                        ${escapeHtml(rel.related_entry_title)}
                    </a>
                    ${rel.related_entry_status ? `
                        <span class="badge ms-2" style="background-color: ${statusColor}; color: ${textColor}; font-size: 0.75rem;">
                            ${escapeHtml(rel.related_entry_status)}
                        </span>
                    ` : ''}
                </td>
                ${def.allow_quantity_unit ? `
                    <td class="text-center" style="width: 150px;">
                        <small class="text-muted">
                            ${rel.quantity ? `${rel.quantity} ${rel.unit || ''}` : '-'}
                        </small>
                    </td>
                ` : ''}
                <td class="text-end" style="width: 100px;">
                    <div class="btn-group btn-group-sm">
                        ${def.allow_quantity_unit ? `
                            <button class="btn btn-outline-secondary btn-edit-quantity" 
                                    data-relationship-id="${rel.relationship_id}"
                                    data-quantity="${rel.quantity || ''}"
                                    data-unit="${rel.unit || ''}"
                                    title="Edit quantity/unit">
                                <i class="fas fa-edit"></i>
                            </button>
                        ` : ''}
                        <button class="btn btn-outline-danger btn-delete-relationship" 
                                data-relationship-id="${rel.relationship_id}"
                                data-entry-title="${escapeHtml(rel.related_entry_title)}"
                                title="Delete relationship">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }
    
    // Function to apply filters
    function applyFilters(definitionId) {
        const card = document.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
        if (!card) return;
        
        const stateFilter = card.querySelector('.relationship-state-filter');
        const selectedValues = stateFilter ? Array.from(stateFilter.selectedOptions).map(opt => opt.value) : [];
        
        const rows = card.querySelectorAll('.relationship-item-row');
        rows.forEach(row => {
            const rowCategory = row.dataset.statusCategory || 'active';
            const rowState = (row.dataset.status || '').toLowerCase();
            
            // If "All Status" is selected or nothing selected, show all rows
            if (selectedValues.length === 0 || selectedValues.includes('')) {
                row.style.display = '';
                return;
            }
            
            // Check if row matches any of the selected filters
            let matches = false;
            
            // Check for category matches (active/inactive)
            if (selectedValues.includes('active') && rowCategory === 'active') {
                matches = true;
            }
            if (selectedValues.includes('inactive') && rowCategory === 'inactive') {
                matches = true;
            }
            
            // Check for specific state match
            if (selectedValues.includes(rowState)) {
                matches = true;
            }
            
            row.style.display = matches ? '' : 'none';
        });
    }
    
    // Function to load available states for a relationship definition
    async function loadStatesForDefinition(definitionId) {
        try {
            const def = relationshipDefinitions.find(d => d.id == definitionId);
            if (!def) return;
            
            const isFromSide = def.entry_type_id_from === currentEntryTypeId;
            const targetTypeId = isFromSide ? def.entry_type_id_to : def.entry_type_id_from;
            
            // Fetch states for the target entry type
            const response = await fetch(`/api/entry_types/${targetTypeId}/states`);
            const states = await response.json();
            
            // Populate the state filter select dropdown
            const card = document.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (!card) return;
            
            const stateSelect = card.querySelector('.relationship-state-filter');
            if (!stateSelect) return;
            
            // Get the optgroup element
            const optgroup = stateSelect.querySelector('optgroup');
            if (!optgroup) return;
            
            // Clear existing options in the optgroup
            optgroup.innerHTML = '';
            
            // Group states by category
            const activeStates = states.filter(s => s.category === 'active');
            const inactiveStates = states.filter(s => s.category === 'inactive');
            
            // Add active states
            if (activeStates.length > 0) {
                activeStates.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                    const option = document.createElement('option');
                    option.value = state.name.toLowerCase();
                    option.textContent = `✓ ${state.name}`;
                    option.dataset.category = 'active';
                    optgroup.appendChild(option);
                });
            }
            
            // Add inactive states
            if (inactiveStates.length > 0) {
                inactiveStates.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                    const option = document.createElement('option');
                    option.value = state.name.toLowerCase();
                    option.textContent = `✕ ${state.name}`;
                    option.dataset.category = 'inactive';
                    optgroup.appendChild(option);
                });
            }
            
        } catch (error) {
            console.error('Error loading states for definition:', error);
        }
    }
    
    // Function to save filter preference for a relationship definition
    async function saveFilterPreference(definitionId) {
        try {
            const card = document.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (!card) return;
            
            const stateFilter = card.querySelector('.relationship-state-filter');
            // Get selected values as comma-separated string (excluding empty "All Status")
            const selectedValues = stateFilter ? 
                Array.from(stateFilter.selectedOptions)
                    .map(opt => opt.value)
                    .filter(val => val !== '')
                    .join(',') : '';
            
            const preference = {
                relationship_definition_id: parseInt(definitionId),
                status_category: '',  // No longer used but kept for backend compatibility
                specific_state: selectedValues
            };
            
            const response = await fetch('/api/relationship_filter_preferences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(preference)
            });
            
            if (response.ok) {
                showNotification('Filter preference saved successfully', 'success');
            } else {
                throw new Error('Failed to save preference');
            }
        } catch (error) {
            console.error('Error saving filter preference:', error);
            showNotification('Error saving preference: ' + error.message, 'danger');
        }
    }
    
    // Function to load saved filter preferences
    async function loadFilterPreferences() {
        try {
            const response = await fetch('/api/relationship_filter_preferences');
            const preferences = await response.json();
            
            preferences.forEach(pref => {
                const card = document.querySelector(`.relationship-type-card[data-definition-id="${pref.relationship_definition_id}"]`);
                if (!card) return;
                
                const stateFilter = card.querySelector('.relationship-state-filter');
                
                if (stateFilter && pref.specific_state) {
                    // Parse comma-separated values and select them
                    const values = pref.specific_state.split(',').filter(v => v.trim());
                    if (values.length > 0) {
                        // Deselect all first
                        Array.from(stateFilter.options).forEach(option => {
                            option.selected = false;
                        });
                        // Select the saved values
                        Array.from(stateFilter.options).forEach(option => {
                            if (values.includes(option.value)) {
                                option.selected = true;
                            }
                        });
                    }
                }
                
                // Apply the loaded filters
                applyFilters(pref.relationship_definition_id);
            });
        } catch (error) {
            console.error('Error loading filter preferences:', error);
        }
    }
    
    function attachEventListeners() {
        // State filter dropdowns
        document.querySelectorAll('.relationship-state-filter').forEach(filter => {
            filter.addEventListener('change', function() {
                applyFilters(this.dataset.definitionId);
            });
        });
        
        // Save filter buttons
        document.querySelectorAll('.btn-save-filter').forEach(btn => {
            btn.addEventListener('click', async function() {
                const definitionId = this.dataset.definitionId;
                await saveFilterPreference(definitionId);
            });
        });
        
        // Add relationship buttons
        document.querySelectorAll('.btn-add-relationship').forEach(btn => {
            btn.addEventListener('click', function() {
                const definitionId = this.dataset.definitionId;
                const label = this.dataset.label;
                const targetTypeId = this.dataset.targetTypeId;
                const targetTypeLabel = this.dataset.targetTypeLabel;
                const allowQuantity = this.dataset.allowQuantity === 'true';
                
                openAddRelationshipModal(definitionId, label, targetTypeId, targetTypeLabel, allowQuantity);
            });
        });
        
        // Delete relationship buttons
        document.querySelectorAll('.btn-delete-relationship').forEach(btn => {
            btn.addEventListener('click', function() {
                const relationshipId = this.dataset.relationshipId;
                const entryTitle = this.dataset.entryTitle;
                deleteRelationship(relationshipId, entryTitle);
            });
        });
        
        // Edit quantity buttons
        document.querySelectorAll('.btn-edit-quantity').forEach(btn => {
            btn.addEventListener('click', function() {
                const relationshipId = this.dataset.relationshipId;
                const quantity = this.dataset.quantity;
                const unit = this.dataset.unit;
                editQuantity(relationshipId, quantity, unit);
            });
        });
    }
    
    function openAddRelationshipModal(definitionId, label, targetTypeId, targetTypeLabel, allowQuantity) {
        // Create and show modal
        const modalId = 'addRelModal_' + definitionId;
        
        // Remove existing modal if any
        const existingModal = document.getElementById(modalId);
        if (existingModal) {
            existingModal.remove();
        }
        
        const modalHtml = `
            <div class="modal fade" id="${modalId}" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-plus me-2"></i>
                                Add ${escapeHtml(label)}
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Search existing entries -->
                            <div class="mb-3">
                                <label class="form-label">Search Existing ${escapeHtml(targetTypeLabel)}</label>
                                <input type="text" 
                                       class="form-control" 
                                       id="searchEntry_${definitionId}"
                                       placeholder="Start typing to search...">
                                <div id="searchResults_${definitionId}" 
                                     class="list-group mt-2" 
                                     style="max-height: 200px; overflow-y: auto; display: none;">
                                </div>
                            </div>
                            
                            <div class="text-center my-3">
                                <span class="text-muted">— OR —</span>
                            </div>
                            
                            <!-- Create new entry -->
                            <div class="form-check mb-3">
                                <input class="form-check-input" 
                                       type="checkbox" 
                                       id="createNew_${definitionId}">
                                <label class="form-check-label" for="createNew_${definitionId}">
                                    Create a new ${escapeHtml(targetTypeLabel)} instead
                                </label>
                            </div>
                            
                            <div id="newEntryFields_${definitionId}" style="display: none;">
                                <div class="mb-3">
                                    <label class="form-label">Title *</label>
                                    <input type="text" 
                                           class="form-control" 
                                           id="newEntryTitle_${definitionId}"
                                           placeholder="Enter title">
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Description</label>
                                    <textarea class="form-control" 
                                              id="newEntryDescription_${definitionId}"
                                              rows="3"
                                              placeholder="Optional description"></textarea>
                                </div>
                            </div>
                            
                            ${allowQuantity ? `
                                <hr class="my-3">
                                <div class="row">
                                    <div class="col-6">
                                        <label class="form-label">Quantity</label>
                                        <input type="number" 
                                               step="any" 
                                               class="form-control" 
                                               id="quantity_${definitionId}"
                                               placeholder="e.g., 2.5">
                                    </div>
                                    <div class="col-6">
                                        <label class="form-label">Unit</label>
                                        <input type="text" 
                                               class="form-control" 
                                               id="unit_${definitionId}"
                                               placeholder="e.g., kg, cups">
                                    </div>
                                </div>
                            ` : ''}
                            
                            <input type="hidden" id="selectedEntryId_${definitionId}">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                Cancel
                            </button>
                            <button type="button" 
                                    class="btn btn-primary" 
                                    id="btnSubmit_${definitionId}">
                                <i class="fas fa-check me-1"></i>
                                Add Relationship
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = new bootstrap.Modal(document.getElementById(modalId));
        modal.show();
        
        // Setup modal interactions
        setupModalInteractions(modalId, definitionId, targetTypeId, allowQuantity);
        
        // Cleanup on hide
        document.getElementById(modalId).addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    }
    
    async function setupModalInteractions(modalId, definitionId, targetTypeId, allowQuantity) {
        const searchInput = document.getElementById(`searchEntry_${definitionId}`);
        const searchResults = document.getElementById(`searchResults_${definitionId}`);
        const createNewCheckbox = document.getElementById(`createNew_${definitionId}`);
        const newEntryFields = document.getElementById(`newEntryFields_${definitionId}`);
        const selectedEntryIdInput = document.getElementById(`selectedEntryId_${definitionId}`);
        const submitBtn = document.getElementById(`btnSubmit_${definitionId}`);
        
        // Get already related entry IDs for this definition to exclude them
        const alreadyRelatedIds = new Set();
        try {
            const relResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relResponse.json();
            relationships.forEach(rel => {
                if (rel.definition_id == definitionId) {
                    alreadyRelatedIds.add(rel.related_entry_id);
                }
            });
            // Also exclude the current entry itself
            alreadyRelatedIds.add(parseInt(entryId));
            
            console.log('Excluded entry IDs for definition', definitionId, ':', Array.from(alreadyRelatedIds));
        } catch (error) {
            console.error('Error fetching existing relationships:', error);
        }
        
        let searchTimeout;
        
        // Search functionality
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            if (query.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(`/api/search_entries?q=${encodeURIComponent(query)}&entry_type_id=${targetTypeId}`);
                    const entries = await response.json();
                    
                    // Filter out already related entries
                    const availableEntries = entries.filter(entry => !alreadyRelatedIds.has(entry.id));
                    
                    if (availableEntries.length === 0) {
                        searchResults.innerHTML = '<div class="list-group-item text-muted">No available entries found</div>';
                    } else {
                        searchResults.innerHTML = availableEntries.map(entry => `
                            <button type="button" 
                                    class="list-group-item list-group-item-action search-result-item"
                                    data-entry-id="${entry.id}"
                                    data-entry-title="${escapeHtml(entry.title)}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <span>${escapeHtml(entry.title)}</span>
                                    <small class="badge bg-secondary">${escapeHtml(entry.status || 'Active')}</small>
                                </div>
                            </button>
                        `).join('');
                        
                        // Attach click handlers
                        document.querySelectorAll('.search-result-item').forEach(item => {
                            item.addEventListener('click', function() {
                                selectedEntryIdInput.value = this.dataset.entryId;
                                searchInput.value = this.dataset.entryTitle;
                                searchResults.style.display = 'none';
                                
                                // Uncheck create new
                                createNewCheckbox.checked = false;
                                newEntryFields.style.display = 'none';
                            });
                        });
                    }
                    
                    searchResults.style.display = 'block';
                } catch (error) {
                    console.error('Search error:', error);
                    searchResults.innerHTML = '<div class="list-group-item text-danger">Search failed</div>';
                    searchResults.style.display = 'block';
                }
            }, 300);
        });
        
        // Create new toggle
        createNewCheckbox.addEventListener('change', function() {
            if (this.checked) {
                newEntryFields.style.display = 'block';
                searchInput.disabled = true;
                selectedEntryIdInput.value = '';
                searchResults.style.display = 'none';
            } else {
                newEntryFields.style.display = 'none';
                searchInput.disabled = false;
            }
        });
        
        // Submit
        submitBtn.addEventListener('click', async function() {
            const isCreatingNew = createNewCheckbox.checked;
            const quantity = allowQuantity ? document.getElementById(`quantity_${definitionId}`).value : null;
            const unit = allowQuantity ? document.getElementById(`unit_${definitionId}`).value : null;
            
            if (isCreatingNew) {
                const title = document.getElementById(`newEntryTitle_${definitionId}`).value.trim();
                const description = document.getElementById(`newEntryDescription_${definitionId}`).value.trim();
                
                if (!title) {
                    alert('Please enter a title for the new entry');
                    return;
                }
                
                await createNewAndLink(definitionId, title, description, quantity, unit);
            } else {
                const targetEntryId = selectedEntryIdInput.value;
                
                if (!targetEntryId) {
                    alert('Please search and select an entry, or choose to create a new one');
                    return;
                }
                
                await linkExisting(definitionId, targetEntryId, quantity, unit);
            }
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById(modalId)).hide();
        });
    }
    
    async function linkExisting(definitionId, targetEntryId, quantity, unit) {
        try {
            const payload = {
                definition_id: parseInt(definitionId),
                related_entry_id: parseInt(targetEntryId)
            };
            
            if (quantity) payload.quantity = parseFloat(quantity);
            if (unit) payload.unit = unit;
            
            const response = await fetch(`/api/entries/${entryId}/relationships`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create relationship');
            }
            
            // Reload relationships
            await loadRelationships();
            
            showNotification('Relationship created successfully', 'success');
        } catch (error) {
            console.error('Error creating relationship:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function createNewAndLink(definitionId, title, description, quantity, unit) {
        try {
            const payload = {
                definition_id: parseInt(definitionId),
                name: title,
                description: description
            };
            
            if (quantity) payload.quantity = parseFloat(quantity);
            if (unit) payload.unit = unit;
            
            const response = await fetch(`/api/entries/${entryId}/relationships/new`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create entry and relationship');
            }
            
            // Reload relationships
            await loadRelationships();
            
            showNotification('New entry created and linked successfully', 'success');
        } catch (error) {
            console.error('Error creating entry:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function deleteRelationship(relationshipId, entryTitle) {
        if (!confirm(`Delete relationship with "${entryTitle}"?`)) {
            return;
        }
        
        try {
            const response = await fetch(`/api/relationships/${relationshipId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error('Failed to delete relationship');
            }
            
            await loadRelationships();
            showNotification('Relationship deleted', 'success');
        } catch (error) {
            console.error('Error deleting relationship:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function editQuantity(relationshipId, currentQuantity, currentUnit) {
        const newQuantity = prompt('Enter quantity:', currentQuantity);
        if (newQuantity === null) return;
        
        const newUnit = prompt('Enter unit:', currentUnit);
        if (newUnit === null) return;
        
        try {
            const response = await fetch(`/api/relationships/${relationshipId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    quantity: parseFloat(newQuantity) || null,
                    unit: newUnit || null
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to update quantity/unit');
            }
            
            await loadRelationships();
            showNotification('Quantity/unit updated', 'success');
        } catch (error) {
            console.error('Error updating quantity:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    function showNotification(message, type) {
        // Simple notification - you can enhance this
        const alertClass = type === 'success' ? 'alert-success' : 'alert-danger';
        const icon = type === 'success' ? 'check-circle' : 'exclamation-triangle';
        
        const notification = document.createElement('div');
        notification.className = `alert ${alertClass} alert-dismissible fade show position-fixed top-0 start-50 translate-middle-x mt-3`;
        notification.style.zIndex = '9999';
        notification.innerHTML = `
            <i class="fas fa-${icon} me-2"></i>
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Toggle visibility of empty relationship cards
    window['toggleEmptyRelationships' + entryId] = function() {
        const emptyCards = document.querySelectorAll('#relationshipsSection' + entryId + ' .empty-relationship-card');
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + entryId);
        const toggleText = toggleBtn.querySelector('.toggle-text');
        const toggleIcon = toggleBtn.querySelector('i');
        
        // Check current state - if any empty card is hidden, we're in "hidden" state
        const isHidden = Array.from(emptyCards).some(card => card.style.display === 'none');
        
        emptyCards.forEach(card => {
            if (isHidden) {
                // Show the card
                card.style.display = 'block';
                card.style.opacity = '0';
                card.style.maxHeight = '0';
                card.style.marginBottom = '0';
                // Trigger reflow
                card.offsetHeight;
                // Animate in
                setTimeout(() => {
                    card.style.opacity = '1';
                    card.style.maxHeight = '1000px';
                    card.style.marginBottom = '1rem';
                }, 10);
            } else {
                // Hide the card
                card.style.opacity = '0';
                card.style.maxHeight = '0';
                card.style.marginBottom = '0';
                setTimeout(() => {
                    card.style.display = 'none';
                }, 300); // Match transition duration
            }
        });
        
        // Update button text and icon
        if (isHidden) {
            toggleText.textContent = 'Hide Empty';
            toggleIcon.className = 'fas fa-eye-slash me-1';
        } else {
            toggleText.textContent = 'Show Empty';
            toggleIcon.className = 'fas fa-eye me-1';
        }
    };
    
    // Hierarchy view functionality
    let hierarchyLoaded = false;
    
    async function loadHierarchy() {
        if (hierarchyLoaded) return;
        
        const loadingDiv = document.getElementById('hierarchyLoading' + entryId);
        const contentDiv = document.getElementById('hierarchyContent' + entryId);
        
        if (!loadingDiv || !contentDiv) return;
        
        loadingDiv.style.display = 'flex';
        contentDiv.innerHTML = '';
        
        try {
            const response = await fetch(`/api/entries/${entryId}/relationships/hierarchy`);
            const data = await response.json();
            
            if (!response.ok) {
                throw new Error(data.error || 'Failed to load hierarchy');
            }
            
            const hierarchy = data.hierarchy || [];
            renderHierarchyTree(hierarchy, contentDiv);
            hierarchyLoaded = true;
            
        } catch (error) {
            console.error('Error loading hierarchy:', error);
            contentDiv.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading hierarchy: ${escapeHtml(error.message)}
                    <button class="btn btn-sm btn-outline-danger ms-3" onclick="retryLoadHierarchy${entryId}()">
                        <i class="fas fa-redo me-1"></i>Retry
                    </button>
                </div>
            `;
        } finally {
            loadingDiv.style.display = 'none';
        }
    }
    
    function renderHierarchyTree(hierarchy, container) {
        console.log('renderHierarchyTree called with:', hierarchy);
        console.log('Hierarchy length:', hierarchy ? hierarchy.length : 0);
        console.log('First node:', hierarchy && hierarchy.length > 0 ? hierarchy[0] : null);
        
        if (!hierarchy || hierarchy.length === 0) {
            container.innerHTML = `
                <div class="hierarchy-empty-state">
                    <i class="fas fa-sitemap"></i>
                    <p class="text-muted">No hierarchical relationships found</p>
                    <small class="text-muted d-block mb-2">Parent-child relationships will appear here</small>
                    <a href="/manage_relationships" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-cog me-1"></i>Configure Relationship Definitions
                    </a>
                </div>
            `;
            return;
        }
        
        // Build HTML for each relationship type tree
        let treeHtml = '';
        if (hierarchy.length > 1) {
            console.log('Multiple trees detected:', hierarchy.length);
            // Multiple relationship types - show separate trees with headers
            treeHtml = hierarchy.map((rootNode, index) => {
                const relationshipTypeName = rootNode.relationship_type_name || `Relationship ${index + 1}`;
                console.log(`Tree ${index + 1}: ${relationshipTypeName}`);
                const treeContent = renderTreeNode(rootNode, 0);
                return `
                    <div class="relationship-tree-section mb-4">
                        <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                            <h6 class="text-primary mb-0">
                                <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                            </h6>
                        </div>
                        <div class="relationship-tree">${treeContent}</div>
                    </div>
                `;
            }).join('<hr class="my-3">');
        } else {
            // Single relationship type tree
            const rootNode = hierarchy[0];
            const relationshipTypeName = rootNode.relationship_type_name;
            console.log('Single tree - relationship type name:', relationshipTypeName);
            console.log('Root node:', rootNode);
            const headerHtml = relationshipTypeName ? `
                <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                    <h6 class="text-primary mb-0">
                        <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                    </h6>
                </div>
            ` : '';
            console.log('Header HTML:', headerHtml);
            treeHtml = `${headerHtml}<div class="relationship-tree">${renderTreeNode(rootNode, 0)}</div>`;
            console.log('Final tree HTML length:', treeHtml.length);
        }
        
        container.innerHTML = treeHtml;
        
        // Initialize tree toggles after rendering
        initializeTreeToggles();
    }
    
    function renderTreeNode(node, level) {
        const isTarget = node.is_target || false;  // The entry we're viewing
        const hasChildren = node.children && node.children.length > 0;
        
        const nodeClasses = ['tree-node-content'];
        if (isTarget) nodeClasses.push('current-entry');
        
        let html = `
            <div class="tree-node level-${level}" data-entry-id="${node.id}" style="padding-left: ${level * 20}px;">
                <div class="${nodeClasses.join(' ')}">
        `;
        
        // Toggle button or spacer
        if (hasChildren) {
            html += `
                <button class="tree-toggle-btn" data-node-id="${node.id}">
                    <i class="fas fa-chevron-down"></i>
                </button>
            `;
        } else {
            html += `<span class="tree-spacer"></span>`;
        }
        
        // Entry type icon
        html += `
            <span class="tree-entry-type" 
                  style="color: ${node.entry_type.color || '#6c757d'};"
                  title="${escapeHtml(node.entry_type.label)}">
                <i class="${node.entry_type.icon || 'fas fa-link'}"></i>
            </span>
        `;
        
        // Direction indicator (parent/child arrow)
        const direction = node.direction || 'unknown';
        if (direction === 'ancestor') {
            html += `
                <span class="tree-direction-icon" title="Parent/Ancestor">
                    <i class="fas fa-arrow-up text-primary"></i>
                </span>
            `;
        } else if (direction === 'descendant') {
            html += `
                <span class="tree-direction-icon" title="Child/Descendant">
                    <i class="fas fa-arrow-down text-success"></i>
                </span>
            `;
        }
        
        // Entry title and link
        html += `
            <a href="/entry/${node.id}/v2" 
               class="tree-entry-link ${isTarget ? 'fw-bold' : ''}"
               target="_blank">
                ${escapeHtml(node.title)}
        `;
        
        // Badge for current/target entry
        if (isTarget) {
            html += `<span class="badge bg-success ms-2">Current</span>`;
        }
        html += `</a>`;
        
        // Status badge
        if (node.status) {
            html += `
                <span class="status-badge ms-2">
                    ${escapeHtml(node.status)}
                </span>
            `;
        }
        
        // Relationship type label
        if (node.relationship_type) {
            html += `
                <small class="text-muted ms-2">
                    <i class="fas fa-link"></i> ${escapeHtml(node.relationship_type)}
                </small>
            `;
        }
        
        html += `</div>`; // Close tree-node-content
        
        // Children (recursive)
        if (hasChildren) {
            html += `<div class="tree-children" data-parent-id="${node.id}">`;
            for (const child of node.children) {
                html += renderTreeNode(child, level + 1);
            }
            html += `</div>`;
        }
        
        html += `</div>`; // Close tree-node
        
        return html;
    }
    
    function initializeTreeToggles() {
        const toggleButtons = document.querySelectorAll('.tree-toggle-btn');
        
        toggleButtons.forEach(button => {
            // Remove existing listeners by cloning
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            newButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const nodeId = this.dataset.nodeId;
                const childrenDiv = document.querySelector(`.tree-children[data-parent-id="${nodeId}"]`);
                const icon = this.querySelector('i');
                
                if (childrenDiv) {
                    childrenDiv.classList.toggle('collapsed');
                    
                    if (childrenDiv.classList.contains('collapsed')) {
                        icon.style.transform = 'rotate(-90deg)';
                    } else {
                        icon.style.transform = 'rotate(0deg)';
                    }
                }
            });
        });
    }
    
    // Retry function for hierarchy loading
    window['retryLoadHierarchy' + entryId] = function() {
        hierarchyLoaded = false;
        loadHierarchy();
    };
    
    // Setup tab event listeners
    function setupTabListeners() {
        const hierarchyTab = document.getElementById('hierarchyTab' + entryId + '-tab');
        
        if (hierarchyTab) {
            hierarchyTab.addEventListener('shown.bs.tab', function() {
                loadHierarchy();
            });
        }
    }
    
    // Initialize on load
    loadRelationships();
    setupTabListeners();
})();
</script>
