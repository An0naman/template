{# Relationships Section for Entry Detail V2 - Updated: 2025-11-08 - Multi-Section Support #}
{% set section_unique_id = entry.id ~ '_' ~ (section_id|default('default')) %}

<div class="relationships-section" id="relationshipsSection{{ section_unique_id }}">
  
  <!-- Section Header -->
  <div class="section-header mb-3 d-flex justify-content-between align-items-center">
    <h5 class="mb-0">
      <i class="fas fa-link me-2"></i>
      Related Records
    </h5>
    <div class="d-flex gap-2">
      <button id="toggleReorderMode{{ section_unique_id }}" 
              class="btn btn-sm btn-outline-primary" 
              onclick="toggleReorderMode{{ section_unique_id }}()"
              title="Reorder relationship type cards"
              style="display: none;">
        <i class="fas fa-grip-vertical me-1"></i>
        <span class="reorder-text">Reorder</span>
      </button>
      <button id="toggleEmptyRelationships{{ section_unique_id }}" 
              class="btn btn-sm btn-outline-secondary" 
              onclick="toggleEmptyRelationships{{ section_unique_id }}()"
              title="Show/hide relationship types with no records"
              style="display: none;">
        <i class="fas fa-eye me-1"></i>
        <span class="toggle-text">Show Empty</span>
      </button>
    </div>
  </div>

  <!-- Loading State -->
  <div id="relationshipsLoading{{ section_unique_id }}" class="text-center py-4">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2 text-muted">Loading relationships...</p>
  </div>

  <!-- Section Content -->
  <div id="relatedRecordsContainer{{ section_unique_id }}" style="display: none;">
    
    <!-- Tabs Navigation -->
    <ul class="nav nav-tabs mb-3" id="relationshipsTabs{{ section_unique_id }}" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="groupedTab{{ section_unique_id }}-tab" data-bs-toggle="tab" 
                data-bs-target="#groupedTab{{ section_unique_id }}" type="button" role="tab" 
                aria-controls="groupedTab{{ section_unique_id }}" aria-selected="true">
          <i class="fas fa-th-list me-1"></i> Grouped View
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="hierarchyTab{{ section_unique_id }}-tab" data-bs-toggle="tab" 
                data-bs-target="#hierarchyTab{{ section_unique_id }}" type="button" role="tab" 
                aria-controls="hierarchyTab{{ section_unique_id }}" aria-selected="false">
          <i class="fas fa-sitemap me-1"></i> Hierarchy View
        </button>
      </li>
    </ul>
    
    <!-- Tab Content -->
    <div class="tab-content" id="relationshipsTabContent{{ section_unique_id }}">
      
      <!-- Grouped View Tab (default) -->
      <div class="tab-pane fade show active" id="groupedTab{{ section_unique_id }}" role="tabpanel" 
           aria-labelledby="groupedTab{{ section_unique_id }}-tab">
        <div id="groupedViewContainer{{ section_unique_id }}">
          <!-- Will be populated via JavaScript with cards for each relationship type -->
        </div>
      </div>
      
      <!-- Hierarchy View Tab -->
      <div class="tab-pane fade" id="hierarchyTab{{ section_unique_id }}" role="tabpanel" 
           aria-labelledby="hierarchyTab{{ section_unique_id }}-tab">
        
        <div id="hierarchyLoading{{ section_unique_id }}" class="text-center py-4" style="display: none;">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2 text-muted">Loading hierarchy...</p>
        </div>
        
        <div id="hierarchyContent{{ section_unique_id }}">
          <!-- Will be populated via JavaScript when tab is activated -->
        </div>
      </div>
      
    </div>
  </div>

</div>

<style>
/* Relationship cards styling with theme support */
.relationship-type-card {
    margin-bottom: 1rem;
    border: 1px solid var(--theme-border-color, var(--bs-border-color));
    border-radius: 0.5rem;
    overflow: visible; /* Changed from hidden to allow dropdown menus to overflow */
    background-color: var(--theme-card-bg, var(--bs-body-bg));
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease, transform 0.2s ease, opacity 0.3s ease, max-height 0.3s ease;
}

/* Empty relationship cards - hidden by default */
.empty-relationship-card {
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    margin-bottom: 0;
    transition: opacity 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
}

/* Visual distinction for empty cards when shown */
.empty-relationship-card .card-header {
    background-color: var(--bs-light);
    opacity: 0.85;
}

.empty-relationship-card .card-body {
    background-color: var(--bs-light);
}

[data-bs-theme="dark"] .empty-relationship-card .card-header,
[data-bs-theme="dark"] .empty-relationship-card .card-body {
    background-color: var(--bs-dark);
}

.relationship-type-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
}

.relationship-type-card .card-header {
    background-color: var(--bs-secondary-bg);
    border-bottom: 1px solid var(--bs-border-color);
    padding: 0.75rem 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    overflow: visible; /* Allow dropdown menus to overflow */
    gap: 0.5rem;
}

.relationship-type-card .card-header h6 {
    font-weight: 600;
    color: var(--bs-body-color);
}

.relationship-type-card .card-body {
    padding: 0;
    background-color: var(--theme-card-body-bg, var(--bs-body-bg));
}

.relationship-type-card table {
    margin: 0;
}

.relationship-type-card .table > :not(caption) > * > * {
    padding: 0.5rem 1rem;
    border-color: var(--theme-border-color, var(--bs-border-color));
}

.relationship-item-row {
    transition: background-color 0.15s ease;
}

.relationship-item-row:hover {
    background-color: var(--theme-hover-bg, var(--bs-secondary-bg));
}

.relationship-link {
    color: var(--bs-body-color) !important;
    text-decoration: none;
    transition: opacity 0.2s ease;
}

.relationship-link:hover {
    opacity: 0.7;
    text-decoration: underline;
}

.btn-add-relationship {
    white-space: nowrap;
    transition: all 0.2s ease;
}

.btn-add-relationship:hover:not(:disabled) {
    transform: scale(1.05);
}

.btn-add-relationship:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Dark mode adjustments */
[data-bs-theme="dark"] .relationship-type-card {
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

[data-bs-theme="dark"] .relationship-type-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

/* Empty state styling */
.relationships-empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--bs-secondary-color);
}

/* Drag-and-drop styling */
.relationship-type-card.dragging {
    opacity: 0.5;
    cursor: grabbing;
}

.relationship-type-card.drag-over {
    border-top: 3px solid var(--bs-primary);
}

.card-drag-handle {
    cursor: grab;
    user-select: none;
    color: var(--bs-secondary-color);
    transition: color 0.2s ease;
}

.card-drag-handle:hover {
    color: var(--bs-primary);
}

.card-drag-handle:active {
    cursor: grabbing;
}

.reorder-mode-active .relationship-type-card {
    cursor: grab;
}

.reorder-mode-active .relationship-type-card:active {
    cursor: grabbing;
}

.relationships-empty-state i {
    font-size: 3rem;
    opacity: 0.25;
    margin-bottom: 1rem;
}

/* Multi-select dropdown styling - makes it look like regular dropdown when closed */
.relationship-state-filter[multiple] {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 16px 12px;
    padding-right: 2.25rem;
    overflow-y: auto;
}

[data-bs-theme="dark"] .relationship-state-filter[multiple] {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23dee2e6' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
}

/* When focused/opened, expand to show all options (or max 400px) */
.relationship-state-filter[multiple]:focus {
    height: auto !important;
    max-height: 400px;
    min-height: 31px;
}

/* Ensure card header allows dropdown to overflow */
.relationship-type-card .card-header {
    position: relative;
    z-index: 10;
}

/* Hierarchy Tree Styles */
.relationship-tree {
    padding: 1rem 0;
}

.tree-node {
    margin-bottom: 0.25rem;
}

.tree-node-content {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    border-radius: 0.25rem;
    transition: background-color 0.15s ease;
}

.tree-node-content:hover {
    background-color: var(--theme-hover-bg, var(--bs-secondary-bg));
}

.tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.1);
    border-left: 3px solid #0d6efd;
}

[data-bs-theme="dark"] .tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.2);
}

.tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.1);
    border-left: 3px solid #0dcaf0;
}

[data-bs-theme="dark"] .tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.15);
}

.tree-toggle-btn {
    background: none;
    border: none;
    padding: 0.25rem;
    margin-right: 0.5rem;
    cursor: pointer;
    color: var(--bs-secondary);
    transition: transform 0.2s ease, color 0.2s ease;
    width: 20px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.tree-toggle-btn:hover {
    color: var(--bs-primary);
}

.tree-toggle-btn i {
    transition: transform 0.2s ease;
}

.tree-spacer {
    display: inline-block;
    width: 20px;
    margin-right: 0.5rem;
}

.tree-entry-type {
    margin-right: 0.5rem;
    font-size: 1rem;
}

.tree-direction-icon {
    margin-right: 0.5rem;
    font-size: 0.875rem;
    display: inline-flex;
    align-items: center;
}

.tree-direction-icon i {
    font-size: 0.75rem;
}

.tree-entry-link {
    color: var(--bs-body-color);
    text-decoration: none;
    margin-right: 0.5rem;
    transition: color 0.2s ease;
}

.tree-entry-link:hover {
    color: var(--bs-primary);
    text-decoration: underline;
}

.tree-children {
    overflow: hidden;
    max-height: 5000px;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    opacity: 1;
}

.tree-children.collapsed {
    max-height: 0;
    opacity: 0;
}

.status-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    background-color: var(--bs-secondary);
    color: white;
}

/* Empty state for hierarchy */
.hierarchy-empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--bs-secondary-color);
}

.hierarchy-empty-state i {
    font-size: 3rem;
    opacity: 0.25;
    margin-bottom: 1rem;
    display: block;
}

/* Tabs styling */
.nav-tabs {
    border-bottom: 2px solid var(--bs-border-color);
}

.nav-tabs .nav-link {
    color: var(--bs-secondary-color);
    border: none;
    border-bottom: 2px solid transparent;
    margin-bottom: -2px;
}

.nav-tabs .nav-link:hover {
    color: var(--bs-body-color);
    border-bottom-color: var(--bs-secondary);
}

.nav-tabs .nav-link.active {
    color: var(--bs-primary);
    background-color: transparent;
    border-bottom-color: var(--bs-primary);
}
</style>

<script>
// Version: 2025-11-08 - Multi-Section Support with Unique IDs
(function() {
    const entryId = {{ entry.id }};
    const entryTypeId = {{ entry.entry_type_id }};
    const sectionId = {{ section_id|default('null') }};  // Section definition ID from section_order
    const sectionUniqueId = '{{ section_unique_id }}';
    const currentEntryTypeId = {{ entry.entry_type_id }};  // Keep for compatibility
    
    console.log('=== Relationships Section V2 Loaded - Section:', sectionUniqueId, '===');
    
    // Store definitions globally for this entry
    let relationshipDefinitions = [];
    
    // Note binding state: Map of entry_id -> boolean (whether binding is enabled)
    let noteBingingState = new Map();
    
    // Utility function: Get contrasting text color for a background color
    function getContrastColor(hexColor) {
        if (!hexColor) return '#fff';
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        return luminance > 0.5 ? '#000' : '#fff';
    }
    
    // Store custom grid order
    let customGridOrder = {};
    
    async function loadRelationships() {
        const loadingEl = document.getElementById('relationshipsLoading' + sectionUniqueId);
        const containerEl = document.getElementById('relatedRecordsContainer' + sectionUniqueId);
        
        try {
            // Fetch relationship definitions
            const defsResponse = await fetch('/api/relationship_definitions');
            const definitions = await defsResponse.json();
            
            // Filter to relevant definitions for this entry type
            relationshipDefinitions = definitions.filter(def => 
                def.entry_type_id_from === currentEntryTypeId || 
                def.entry_type_id_to === currentEntryTypeId
            );
            
            // Fetch existing relationships
            const relsResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relsResponse.json();
            
            // Fetch custom grid order for this entry type
            try {
                const orderResponse = await fetch(`/api/entry_types/${currentEntryTypeId}/relationship_grid_order`);
                customGridOrder = await orderResponse.json();
            } catch (error) {
                console.warn('Could not load grid order, using default:', error);
                customGridOrder = {};
            }
            
            // Group relationships by definition ID
            const groupedRelationships = {};
            relationships.forEach(rel => {
                if (!groupedRelationships[rel.definition_id]) {
                    groupedRelationships[rel.definition_id] = [];
                }
                groupedRelationships[rel.definition_id].push(rel);
            });
            
            // Sort definitions by custom order if available
            const sortedDefinitions = [...relationshipDefinitions].sort((a, b) => {
                const orderA = customGridOrder[a.id] !== undefined ? customGridOrder[a.id] : 999;
                const orderB = customGridOrder[b.id] !== undefined ? customGridOrder[b.id] : 999;
                return orderA - orderB;
            });
            
            // Render the cards (await to ensure filters are applied after states are loaded)
            await renderRelationshipCards(sortedDefinitions, groupedRelationships);
            
            loadingEl.style.display = 'none';
            containerEl.style.display = 'block';
            
        } catch (error) {
            console.error('Error loading relationships:', error);
            loadingEl.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading relationships: ${error.message}
                </div>
            `;
        }
    }
    
    async function renderRelationshipCards(definitions, groupedRelationships) {
        const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
        
        if (!container) {
            console.error('Grouped view container not found');
            return;
        }
        
        if (definitions.length === 0) {
            container.innerHTML = `
                <div class="relationships-empty-state">
                    <i class="fas fa-link"></i>
                    <p>No relationship types available for this entry type.</p>
                </div>
            `;
            return;
        }
        
        let html = '';
        let hasEmptyCards = false;
        
        definitions.forEach(def => {
            const isFromSide = def.entry_type_id_from === currentEntryTypeId;
            const relationships = groupedRelationships[def.id] || [];
            
            // Determine the appropriate label and cardinality
            const displayLabel = isFromSide ? def.label_from_side : def.label_to_side;
            const relevantCardinality = isFromSide ? def.cardinality_from : def.cardinality_to;
            const canAddMore = relevantCardinality === -1 || relationships.length < relevantCardinality;
            
            // Check if this card is empty
            const isEmpty = relationships.length === 0;
            if (isEmpty) hasEmptyCards = true;
            
            html += `
                <div class="relationship-type-card ${isEmpty ? 'empty-relationship-card' : ''}" 
                     data-definition-id="${def.id}"
                     draggable="false"
                     style="${isEmpty ? 'display: none;' : ''}">
                    <div class="card-header">
                        <div class="d-flex align-items-center gap-2">
                            <i class="fas fa-grip-vertical card-drag-handle" 
                               style="display: none;"
                               title="Drag to reorder"></i>
                            <h6 class="mb-0">${escapeHtml(displayLabel || def.name)}</h6>
                        </div>
                        <div class="d-flex gap-2 align-items-center flex-wrap">
                            <select class="form-select form-select-sm relationship-state-filter" 
                                    data-definition-id="${def.id}"
                                    multiple
                                    style="width: auto; min-width: 180px; height: 31px;"
                                    title="Filter by status (Ctrl+Click for multiple)">
                                <option value="">All Status</option>
                                <option value="active">✓ Active (Ongoing)</option>
                                <option value="inactive">✕ Inactive (Completed)</option>
                                <optgroup label="Specific Status">
                                    <!-- Will be populated dynamically -->
                                </optgroup>
                            </select>
                            <button class="btn btn-sm btn-outline-secondary btn-save-filter" 
                                    data-definition-id="${def.id}"
                                    title="Save current filter as default for this relationship type">
                                <i class="fas fa-save"></i>
                            </button>
                            <button class="btn btn-sm btn-primary btn-add-relationship" 
                                    data-definition-id="${def.id}"
                                    data-label="${escapeHtml(displayLabel || def.name)}"
                                    data-target-type-id="${isFromSide ? def.entry_type_id_to : def.entry_type_id_from}"
                                    data-target-type-label="${isFromSide ? def.entry_type_to_label : def.entry_type_from_label}"
                                    data-allow-quantity="${def.allow_quantity_unit}"
                                    ${!canAddMore ? 'disabled' : ''}
                                    title="${canAddMore ? 'Add ' + (displayLabel || def.name) : 'Maximum entries reached'}">
                                <i class="fas fa-plus me-1"></i>Add
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        ${relationships.length > 0 ? `
                            <table class="table table-sm table-hover mb-0">
                                <tbody>
                                    ${relationships.map(rel => renderRelationshipRow(rel, def)).join('')}
                                </tbody>
                            </table>
                        ` : `
                            <div class="text-center py-3 text-muted">
                                <small>No relationships yet. Click "Add" to create one.</small>
                            </div>
                        `}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        
        // Show/hide the toggle button based on whether there are empty cards
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + sectionUniqueId);
        if (toggleBtn) {
            toggleBtn.style.display = hasEmptyCards ? 'inline-block' : 'none';
        }
        
        // Attach event listeners
        attachEventListeners();
        
        // Load states for each relationship definition's filter dropdown
        // Wait for all state loading to complete before applying filter preferences
        const stateLoadPromises = definitions.map(def => loadStatesForDefinition(def.id));
        await Promise.all(stateLoadPromises);
        
        // Load and apply saved filter preferences (after states are loaded)
        await loadFilterPreferences();
    }
    
    function renderRelationshipRow(rel, def) {
        const statusColor = rel.related_entry_status_color || '#6c757d';
        const textColor = getContrastColor(statusColor);
        // Determine status category - we'll need to get this from the API or infer it
        const statusCategory = rel.related_entry_status_category || 'active'; // Default to active if not provided
        const statusName = rel.related_entry_status || '';
        
        return `
            <tr class="relationship-item-row" 
                data-status-category="${statusCategory}" 
                data-status="${statusName.toLowerCase()}">
                <td>
                    <a href="/entry/${rel.related_entry_id}" class="relationship-link">
                        ${escapeHtml(rel.related_entry_title)}
                    </a>
                    ${rel.related_entry_status ? `
                        <span class="badge ms-2" style="background-color: ${statusColor}; color: ${textColor}; font-size: 0.75rem;">
                            ${escapeHtml(rel.related_entry_status)}
                        </span>
                    ` : ''}
                </td>
                ${def.allow_quantity_unit ? `
                    <td class="text-center" style="width: 150px;">
                        <small class="text-muted">
                            ${rel.quantity ? `${rel.quantity} ${rel.unit || ''}` : '-'}
                        </small>
                    </td>
                ` : ''}
                <td class="text-end" style="width: 150px;">
                    <div class="btn-group btn-group-sm">
                        ${def.allow_quantity_unit ? `
                            <button type="button" class="btn btn-outline-secondary btn-edit-quantity" 
                                    data-relationship-id="${rel.relationship_id}"
                                    data-quantity="${rel.quantity || ''}"
                                    data-unit="${rel.unit || ''}"
                                    title="Edit quantity/unit">
                                <i class="fas fa-edit"></i>
                            </button>
                        ` : ''}
                        <button type="button" class="btn btn-outline-primary btn-bind-notes" 
                                data-entry-id="${rel.related_entry_id}" 
                                data-entry-title="${escapeHtml(rel.related_entry_title)}" 
                                title="Bind notes from this entry">
                            <i class="fas fa-link"></i>
                        </button>
                        <button type="button" class="btn btn-outline-danger btn-delete-relationship" 
                                data-relationship-id="${rel.relationship_id}"
                                data-entry-title="${escapeHtml(rel.related_entry_title)}"
                                title="Delete relationship">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }
    
    // Function to apply filters
    function applyFilters(definitionId) {
        // Get the container for this specific section instance
        const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
        if (!container) return;
        
        // Scope the query to this section's container
        const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
        if (!card) return;
        
        const stateFilter = card.querySelector('.relationship-state-filter');
        const selectedValues = stateFilter ? Array.from(stateFilter.selectedOptions).map(opt => opt.value) : [];
        
        const rows = card.querySelectorAll('.relationship-item-row');
        rows.forEach(row => {
            const rowCategory = row.dataset.statusCategory || 'active';
            const rowState = (row.dataset.status || '').toLowerCase();
            
            // If "All Status" is selected or nothing selected, show all rows
            if (selectedValues.length === 0 || selectedValues.includes('')) {
                row.style.display = '';
                return;
            }
            
            // Check if row matches any of the selected filters
            let matches = false;
            
            // Check for category matches (active/inactive)
            if (selectedValues.includes('active') && rowCategory === 'active') {
                matches = true;
            }
            if (selectedValues.includes('inactive') && rowCategory === 'inactive') {
                matches = true;
            }
            
            // Check for specific state match
            if (selectedValues.includes(rowState)) {
                matches = true;
            }
            
            row.style.display = matches ? '' : 'none';
        });
    }
    
    // Function to load available states for a relationship definition
    async function loadStatesForDefinition(definitionId) {
        try {
            const def = relationshipDefinitions.find(d => d.id == definitionId);
            if (!def) return;
            
            const isFromSide = def.entry_type_id_from === currentEntryTypeId;
            const targetTypeId = isFromSide ? def.entry_type_id_to : def.entry_type_id_from;
            
            // Fetch states for the target entry type
            const response = await fetch(`/api/entry_types/${targetTypeId}/states`);
            const states = await response.json();
            
            // Get the container for this specific section instance
            const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
            if (!container) return;
            
            // Populate the state filter select dropdown - scoped to this section's container
            const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (!card) return;
            
            const stateSelect = card.querySelector('.relationship-state-filter');
            if (!stateSelect) return;
            
            // Get the optgroup element
            const optgroup = stateSelect.querySelector('optgroup');
            if (!optgroup) return;
            
            // Clear existing options in the optgroup
            optgroup.innerHTML = '';
            
            // Group states by category
            const activeStates = states.filter(s => s.category === 'active');
            const inactiveStates = states.filter(s => s.category === 'inactive');
            
            // Add active states
            if (activeStates.length > 0) {
                activeStates.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                    const option = document.createElement('option');
                    option.value = state.name.toLowerCase();
                    option.textContent = `✓ ${state.name}`;
                    option.dataset.category = 'active';
                    optgroup.appendChild(option);
                });
            }
            
            // Add inactive states
            if (inactiveStates.length > 0) {
                inactiveStates.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                    const option = document.createElement('option');
                    option.value = state.name.toLowerCase();
                    option.textContent = `✕ ${state.name}`;
                    option.dataset.category = 'inactive';
                    optgroup.appendChild(option);
                });
            }
            
        } catch (error) {
            console.error('Error loading states for definition:', error);
        }
    }
    
    // Function to save filter preference for a relationship definition
    async function saveFilterPreference(definitionId) {
        try {
            if (!sectionId) {
                console.error('Section ID is required for saving preferences');
                return;
            }
            
            // Get the container for this specific section instance
            const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
            if (!container) return;
            
            // Scope the query to this section's container
            const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (!card) return;
            
            const stateFilter = card.querySelector('.relationship-state-filter');
            // Get selected values as comma-separated string (excluding empty "All Status")
            const selectedValues = stateFilter ? 
                Array.from(stateFilter.selectedOptions)
                    .map(opt => opt.value)
                    .filter(val => val !== '')
                    .join(',') : '';
            
            const preference = {
                entry_type_id: entryTypeId,
                section_id: sectionId,
                relationship_definition_id: parseInt(definitionId),
                filter_status_category: '',
                filter_specific_states: selectedValues
            };
            
            const response = await fetch('/api/section_relationship_preferences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(preference)
            });
            
            if (response.ok) {
                showNotification('Filter preference saved for all entries of this type', 'success');
            } else {
                throw new Error('Failed to save preference');
            }
        } catch (error) {
            console.error('Error saving filter preference:', error);
            showNotification('Error saving preference: ' + error.message, 'danger');
        }
    }
    
    // Function to load saved filter preferences from section-level config
    async function loadFilterPreferences() {
        try {
            if (!sectionId) {
                console.warn('Section ID not available, skipping filter preferences load');
                return;
            }
            
            const response = await fetch(`/api/section_relationship_preferences?entry_type_id=${entryTypeId}&section_id=${sectionId}`);
            if (!response.ok) {
                console.warn('Failed to load filter preferences');
                return;
            }
            
            const preferences = await response.json();
            
            // Get the container for this specific section instance
            const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
            if (!container) return;
            
            preferences.forEach(pref => {
                // Scope the query to this section's container
                const card = container.querySelector(`.relationship-type-card[data-definition-id="${pref.relationship_definition_id}"]`);
                if (!card) return;
                
                const stateFilter = card.querySelector('.relationship-state-filter');
                
                if (stateFilter && pref.filter_specific_states) {
                    // Parse comma-separated values and select them
                    const values = pref.filter_specific_states.split(',').filter(v => v.trim());
                    if (values.length > 0) {
                        // Deselect all first
                        Array.from(stateFilter.options).forEach(option => {
                            option.selected = false;
                        });
                        // Select the saved values
                        Array.from(stateFilter.options).forEach(option => {
                            if (values.includes(option.value)) {
                                option.selected = true;
                            }
                        });
                    }
                }
                
                // Apply the loaded filters
                applyFilters(pref.relationship_definition_id);
            });
        } catch (error) {
            console.error('Error loading filter preferences:', error);
        }
    }
    
    function attachEventListeners() {
        // Get the container for this specific section instance
        const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
        if (!container) return;
        
        // State filter dropdowns - scoped to this section's container
        container.querySelectorAll('.relationship-state-filter').forEach(filter => {
            filter.addEventListener('change', function() {
                applyFilters(this.dataset.definitionId);
            });
        });
        
        // Save filter buttons - scoped to this section's container
        container.querySelectorAll('.btn-save-filter').forEach(btn => {
            btn.addEventListener('click', async function() {
                const definitionId = this.dataset.definitionId;
                await saveFilterPreference(definitionId);
            });
        });
        
        // Add relationship buttons - scoped to this section's container
        container.querySelectorAll('.btn-add-relationship').forEach(btn => {
            btn.addEventListener('click', function() {
                const definitionId = this.dataset.definitionId;
                const label = this.dataset.label;
                const targetTypeId = this.dataset.targetTypeId;
                const targetTypeLabel = this.dataset.targetTypeLabel;
                const allowQuantity = this.dataset.allowQuantity === 'true';
                
                openAddRelationshipModal(definitionId, label, targetTypeId, targetTypeLabel, allowQuantity);
            });
        });
        
        // Delete relationship buttons - scoped to this section's container
        const deleteButtons = container.querySelectorAll('.btn-delete-relationship');
        console.log(`Found ${deleteButtons.length} delete buttons in section ${sectionUniqueId}`);
        deleteButtons.forEach(btn => {
            btn.addEventListener('click', function(e) {
                console.log('Delete button clicked:', this.dataset.relationshipId);
                const relationshipId = this.dataset.relationshipId;
                const entryTitle = this.dataset.entryTitle;
                deleteRelationship(relationshipId, entryTitle);
            });
        });
        
        // Edit quantity buttons - scoped to this section's container
        container.querySelectorAll('.btn-edit-quantity').forEach(btn => {
            btn.addEventListener('click', function() {
                const relationshipId = this.dataset.relationshipId;
                const quantity = this.dataset.quantity;
                const unit = this.dataset.unit;
                editQuantity(relationshipId, quantity, unit);
            });
        });
        
        // Bind notes buttons - scoped to this section's container
        container.querySelectorAll('.btn-bind-notes').forEach(btn => {
            btn.addEventListener('click', function() {
                const targetEntryId = this.dataset.entryId;
                const targetEntryTitle = this.dataset.entryTitle;
                showBindNotesModal(targetEntryId, targetEntryTitle);
            });
        });
    }
    
    async function openAddRelationshipModal(definitionId, label, targetTypeId, targetTypeLabel, allowQuantity) {
        // Create and show modal
        const modalId = 'addRelModal_' + definitionId;
        
        // Remove existing modal if any
        const existingModal = document.getElementById(modalId);
        if (existingModal) {
            existingModal.remove();
        }
        
        // Check if this definition has any current relationships
        let hasCurrentRelationships = false;
        try {
            const relResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relResponse.json();
            hasCurrentRelationships = relationships.some(rel => rel.definition_id == definitionId);
        } catch (error) {
            console.error('Error checking current relationships:', error);
        }
        
        // Only check for shared relationship opportunities if there are NO current relationships for this definition
        let importOpportunitiesHtml = '';
        if (!hasCurrentRelationships) {
            try {
                const response = await fetch(`/api/entries/${entryId}/shared_relationship_opportunities`);
                if (response.ok) {
                    const allOpportunities = await response.json();
                    
                    // Filter opportunities to only those matching this definition
                    const relevantOpportunities = allOpportunities.filter(opp => 
                        opp.relationship_definition && opp.relationship_definition.id == definitionId
                    );
                    
                    if (relevantOpportunities.length > 0) {
                        const totalTargets = relevantOpportunities.reduce((sum, opp) => 
                            sum + opp.potential_targets.length, 0);
                        
                        importOpportunitiesHtml = `
                            <div class="alert alert-info mb-3">
                                <i class="fas fa-lightbulb me-2"></i>
                                <strong>Quick Import Available:</strong> 
                                Found ${totalTargets} ${escapeHtml(targetTypeLabel.toLowerCase())}${totalTargets !== 1 ? 's' : ''} 
                                from ${relevantOpportunities.length} related ${relevantOpportunities.length === 1 ? 'entry' : 'entries'}.
                                <button type="button" 
                                        class="btn btn-sm btn-success ms-2" 
                                        id="btnShowImport_${definitionId}">
                                    <i class="fas fa-download me-1"></i>
                                    Import from Existing
                                </button>
                            </div>
                            <div id="importSection_${definitionId}" style="display: none;" class="mb-3">
                                ${relevantOpportunities.map((opp, oppIndex) => {
                                    const intermediateEntry = opp.intermediate_entry;
                                    const targets = opp.potential_targets;
                                    const relDef = opp.relationship_definition;
                                    
                                    return `
                                        <div class="card mb-2">
                                            <div class="card-header py-2 d-flex justify-content-between align-items-center">
                                                <div>
                                                    <strong>From: ${escapeHtml(intermediateEntry.title)}</strong>
                                                    <span class="badge bg-secondary ms-2">${targets.length} available</span>
                                                </div>
                                                <div>
                                                    <button type="button" class="btn btn-sm btn-success" 
                                                            onclick="selectAllInGroup${definitionId}(${oppIndex})">
                                                        <i class="fas fa-check-double"></i> All
                                                    </button>
                                                    <button type="button" class="btn btn-sm btn-outline-secondary ms-1" 
                                                            onclick="deselectAllInGroup${definitionId}(${oppIndex})">
                                                        <i class="fas fa-times"></i> None
                                                    </button>
                                                </div>
                                            </div>
                                            <div class="card-body p-2" id="targetGroup_${definitionId}_${oppIndex}">
                                                ${targets.map((target, targetIndex) => {
                                                    const targetEntry = target.target_entry;
                                                    const sourceRel = target.source_relationship;
                                                    const uniqueId = definitionId + '_' + oppIndex + '_' + targetIndex;
                                                    
                                                    return `
                                                        <div class="form-check border rounded p-2 mb-2 import-target-item" 
                                                             data-group="${oppIndex}">
                                                            <input class="form-check-input import-entry-checkbox" 
                                                                   type="checkbox" 
                                                                   checked
                                                                   value="${targetEntry.id}"
                                                                   id="import_${uniqueId}"
                                                                   data-definition-id="${relDef.id}"
                                                                   data-quantity="${sourceRel.quantity || ''}"
                                                                   data-unit="${sourceRel.unit || ''}">
                                                            <label class="form-check-label d-flex justify-content-between align-items-start w-100" 
                                                                   for="import_${uniqueId}">
                                                                <div class="flex-grow-1">
                                                                    <strong>${escapeHtml(targetEntry.title)}</strong>
                                                                    ${targetEntry.status ? `
                                                                        <span class="badge ms-2" 
                                                                              style="background-color: ${targetEntry.status_color || '#6c757d'}; font-size: 0.7rem;">
                                                                            ${escapeHtml(targetEntry.status)}
                                                                        </span>
                                                                    ` : ''}
                                                                </div>
                                                                ${relDef.allow_quantity_unit && (sourceRel.quantity || sourceRel.unit) ? `
                                                                    <div class="text-end ms-2">
                                                                        <small class="text-muted d-block">
                                                                            ${sourceRel.quantity || ''} ${sourceRel.unit || ''}
                                                                        </small>
                                                                    </div>
                                                                ` : ''}
                                                            </label>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                                <div class="d-flex gap-2 mt-3">
                                    <button type="button" 
                                            class="btn btn-sm btn-outline-secondary" 
                                            id="btnSelectAllImport_${definitionId}">
                                        Select All
                                    </button>
                                    <button type="button" 
                                            class="btn btn-sm btn-outline-secondary" 
                                            id="btnDeselectAllImport_${definitionId}">
                                        Deselect All
                                    </button>
                                    <button type="button" 
                                            class="btn btn-sm btn-success ms-auto" 
                                            id="btnExecuteImport_${definitionId}">
                                        <i class="fas fa-check me-1"></i>
                                        Import Selected
                                    </button>
                                </div>
                            </div>
                            
                            <hr class="my-3">
                        `;
                        
                        // Create group selection functions dynamically
                        window[`selectAllInGroup${definitionId}`] = function(groupIndex) {
                            document.querySelectorAll(`#targetGroup_${definitionId}_${groupIndex} .import-entry-checkbox`)
                                .forEach(cb => cb.checked = true);
                        };
                        window[`deselectAllInGroup${definitionId}`] = function(groupIndex) {
                            document.querySelectorAll(`#targetGroup_${definitionId}_${groupIndex} .import-entry-checkbox`)
                                .forEach(cb => cb.checked = false);
                        };
                    }
                }
            } catch (error) {
                console.error('Error checking shared relationship opportunities:', error);
            }
        }
        
        const modalHtml = `
            <div class="modal fade" id="${modalId}" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-plus me-2"></i>
                                Add ${escapeHtml(label)}
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            ${importOpportunitiesHtml}
                            
                            <!-- Search existing entries -->
                            <div class="mb-3">
                                <label class="form-label">Search Existing ${escapeHtml(targetTypeLabel)}</label>
                                <input type="text" 
                                       class="form-control" 
                                       id="searchEntry_${definitionId}"
                                       placeholder="Start typing to search...">
                                <div id="searchResults_${definitionId}" 
                                     class="list-group mt-2" 
                                     style="max-height: 200px; overflow-y: auto; display: none;">
                                </div>
                            </div>
                            
                            <div class="text-center my-3">
                                <span class="text-muted">— OR —</span>
                            </div>
                            
                            <!-- Create new entry -->
                            <div class="form-check mb-3">
                                <input class="form-check-input" 
                                       type="checkbox" 
                                       id="createNew_${definitionId}">
                                <label class="form-check-label" for="createNew_${definitionId}">
                                    Create a new ${escapeHtml(targetTypeLabel)} instead
                                </label>
                            </div>
                            
                            <div id="newEntryFields_${definitionId}" style="display: none;">
                                <div class="mb-3">
                                    <label class="form-label">Title *</label>
                                    <input type="text" 
                                           class="form-control" 
                                           id="newEntryTitle_${definitionId}"
                                           placeholder="Enter title">
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Description</label>
                                    <textarea class="form-control" 
                                              id="newEntryDescription_${definitionId}"
                                              rows="3"
                                              placeholder="Optional description"></textarea>
                                </div>
                            </div>
                            
                            ${allowQuantity ? `
                                <hr class="my-3">
                                <div class="row">
                                    <div class="col-6">
                                        <label class="form-label">Quantity</label>
                                        <input type="number" 
                                               step="any" 
                                               class="form-control" 
                                               id="quantity_${definitionId}"
                                               placeholder="e.g., 2.5">
                                    </div>
                                    <div class="col-6">
                                        <label class="form-label">Unit</label>
                                        <input type="text" 
                                               class="form-control" 
                                               id="unit_${definitionId}"
                                               placeholder="e.g., kg, cups">
                                    </div>
                                </div>
                            ` : ''}
                            
                            <input type="hidden" id="selectedEntryId_${definitionId}">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                Cancel
                            </button>
                            <button type="button" 
                                    class="btn btn-primary" 
                                    id="btnSubmit_${definitionId}">
                                <i class="fas fa-check me-1"></i>
                                Add Relationship
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = new bootstrap.Modal(document.getElementById(modalId));
        modal.show();
        
        // Setup modal interactions
        setupModalInteractions(modalId, definitionId, targetTypeId, allowQuantity);
        
        // Cleanup on hide
        document.getElementById(modalId).addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    }
    
    async function setupModalInteractions(modalId, definitionId, targetTypeId, allowQuantity) {
        const searchInput = document.getElementById(`searchEntry_${definitionId}`);
        const searchResults = document.getElementById(`searchResults_${definitionId}`);
        const createNewCheckbox = document.getElementById(`createNew_${definitionId}`);
        const newEntryFields = document.getElementById(`newEntryFields_${definitionId}`);
        const selectedEntryIdInput = document.getElementById(`selectedEntryId_${definitionId}`);
        const submitBtn = document.getElementById(`btnSubmit_${definitionId}`);
        
        // Get already related entry IDs for this definition to exclude them
        const alreadyRelatedIds = new Set();
        try {
            const relResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relResponse.json();
            relationships.forEach(rel => {
                if (rel.definition_id == definitionId) {
                    alreadyRelatedIds.add(rel.related_entry_id);
                }
            });
            // Also exclude the current entry itself
            alreadyRelatedIds.add(parseInt(entryId));
            
            console.log('Excluded entry IDs for definition', definitionId, ':', Array.from(alreadyRelatedIds));
        } catch (error) {
            console.error('Error fetching existing relationships:', error);
        }
        
        let searchTimeout;
        
        // Search functionality
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            if (query.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(`/api/search_entries?q=${encodeURIComponent(query)}&entry_type_id=${targetTypeId}`);
                    const entries = await response.json();
                    
                    // Filter out already related entries
                    const availableEntries = entries.filter(entry => !alreadyRelatedIds.has(entry.id));
                    
                    if (availableEntries.length === 0) {
                        searchResults.innerHTML = '<div class="list-group-item text-muted">No available entries found</div>';
                    } else {
                        searchResults.innerHTML = availableEntries.map(entry => `
                            <button type="button" 
                                    class="list-group-item list-group-item-action search-result-item"
                                    data-entry-id="${entry.id}"
                                    data-entry-title="${escapeHtml(entry.title)}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <span>${escapeHtml(entry.title)}</span>
                                    <small class="badge bg-secondary">${escapeHtml(entry.status || 'Active')}</small>
                                </div>
                            </button>
                        `).join('');
                        
                        // Attach click handlers
                        document.querySelectorAll('.search-result-item').forEach(item => {
                            item.addEventListener('click', function() {
                                selectedEntryIdInput.value = this.dataset.entryId;
                                searchInput.value = this.dataset.entryTitle;
                                searchResults.style.display = 'none';
                                
                                // Uncheck create new
                                createNewCheckbox.checked = false;
                                newEntryFields.style.display = 'none';
                            });
                        });
                    }
                    
                    searchResults.style.display = 'block';
                } catch (error) {
                    console.error('Search error:', error);
                    searchResults.innerHTML = '<div class="list-group-item text-danger">Search failed</div>';
                    searchResults.style.display = 'block';
                }
            }, 300);
        });
        
        // Create new toggle
        createNewCheckbox.addEventListener('change', function() {
            if (this.checked) {
                newEntryFields.style.display = 'block';
                searchInput.disabled = true;
                selectedEntryIdInput.value = '';
                searchResults.style.display = 'none';
            } else {
                newEntryFields.style.display = 'none';
                searchInput.disabled = false;
            }
        });
        
        // Submit
        submitBtn.addEventListener('click', async function() {
            const isCreatingNew = createNewCheckbox.checked;
            const quantity = allowQuantity ? document.getElementById(`quantity_${definitionId}`).value : null;
            const unit = allowQuantity ? document.getElementById(`unit_${definitionId}`).value : null;
            
            if (isCreatingNew) {
                const title = document.getElementById(`newEntryTitle_${definitionId}`).value.trim();
                const description = document.getElementById(`newEntryDescription_${definitionId}`).value.trim();
                
                if (!title) {
                    alert('Please enter a title for the new entry');
                    return;
                }
                
                await createNewAndLink(definitionId, title, description, quantity, unit);
            } else {
                const targetEntryId = selectedEntryIdInput.value;
                
                if (!targetEntryId) {
                    alert('Please search and select an entry, or choose to create a new one');
                    return;
                }
                
                await linkExisting(definitionId, targetEntryId, quantity, unit);
            }
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById(modalId)).hide();
        });
        
        // Import functionality handlers
        const showImportBtn = document.getElementById(`btnShowImport_${definitionId}`);
        const importSection = document.getElementById(`importSection_${definitionId}`);
        const selectAllBtn = document.getElementById(`btnSelectAllImport_${definitionId}`);
        const deselectAllBtn = document.getElementById(`btnDeselectAllImport_${definitionId}`);
        const executeImportBtn = document.getElementById(`btnExecuteImport_${definitionId}`);
        
        if (showImportBtn && importSection) {
            showImportBtn.addEventListener('click', function() {
                if (importSection.style.display === 'none') {
                    importSection.style.display = 'block';
                    this.innerHTML = '<i class="fas fa-chevron-up me-1"></i>Hide Import Options';
                } else {
                    importSection.style.display = 'none';
                    this.innerHTML = '<i class="fas fa-download me-1"></i>Import from Existing';
                }
            });
        }
        
        if (selectAllBtn) {
            selectAllBtn.addEventListener('click', function() {
                document.querySelectorAll('.import-entry-checkbox').forEach(cb => cb.checked = true);
            });
        }
        
        if (deselectAllBtn) {
            deselectAllBtn.addEventListener('click', function() {
                document.querySelectorAll('.import-entry-checkbox').forEach(cb => cb.checked = false);
            });
        }
        
        if (executeImportBtn) {
            executeImportBtn.addEventListener('click', async function() {
                const selectedEntryIds = Array.from(document.querySelectorAll('.import-entry-checkbox:checked'))
                    .map(cb => parseInt(cb.value));
                
                if (selectedEntryIds.length === 0) {
                    alert('Please select at least one entry to import');
                    return;
                }
                
                await importMultipleEntries(definitionId, selectedEntryIds, allowQuantity);
                
                // Close modal
                bootstrap.Modal.getInstance(document.getElementById(modalId)).hide();
            });
        }
    }
    
    async function linkExisting(definitionId, targetEntryId, quantity, unit) {
        try {
            const payload = {
                definition_id: parseInt(definitionId),
                related_entry_id: parseInt(targetEntryId)
            };
            
            if (quantity) payload.quantity = parseFloat(quantity);
            if (unit) payload.unit = unit;
            
            const response = await fetch(`/api/entries/${entryId}/relationships`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create relationship');
            }
            
            // Reload relationships
            await loadRelationships();
            
            showNotification('Relationship created successfully', 'success');
        } catch (error) {
            console.error('Error creating relationship:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function createNewAndLink(definitionId, title, description, quantity, unit) {
        try {
            const payload = {
                definition_id: parseInt(definitionId),
                name: title,
                description: description
            };
            
            if (quantity) payload.quantity = parseFloat(quantity);
            if (unit) payload.unit = unit;
            
            const response = await fetch(`/api/entries/${entryId}/relationships/new`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create entry and relationship');
            }
            
            // Reload relationships
            await loadRelationships();
            
            showNotification('New entry created and linked successfully', 'success');
        } catch (error) {
            console.error('Error creating entry:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function importMultipleEntries(definitionId, entryIds, allowQuantity) {
        try {
            // Collect all selected entries with their data from the checkboxes
            const relationships = [];
            const checkboxes = document.querySelectorAll('.import-entry-checkbox:checked');
            
            checkboxes.forEach(cb => {
                const relationshipData = {
                    definition_id: parseInt(cb.dataset.definitionId || definitionId),
                    target_entry_id: parseInt(cb.value)
                };
                
                // Include quantity/unit if they exist in the data attributes
                if (cb.dataset.quantity) {
                    relationshipData.quantity = parseFloat(cb.dataset.quantity);
                }
                if (cb.dataset.unit) {
                    relationshipData.unit = cb.dataset.unit;
                }
                
                relationships.push(relationshipData);
            });
            
            if (relationships.length === 0) {
                showNotification('No entries selected for import', 'warning');
                return;
            }
            
            // Show progress notification
            showNotification(`Importing ${relationships.length} relationships...`, 'info');
            
            // Use the V1 shared relationships API endpoint
            const response = await fetch(`/api/entries/${entryId}/create_shared_relationships`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ relationships })
            });
            
            if (!response.ok) {
                let errorMessage = 'Failed to import relationships';
                try {
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        const error = await response.json();
                        errorMessage = error.error || errorMessage;
                    } else {
                        const text = await response.text();
                        errorMessage = `Server error (${response.status}): ${text.substring(0, 100)}`;
                    }
                } catch (parseError) {
                    errorMessage = `Server error (${response.status})`;
                }
                throw new Error(errorMessage);
            }
            
            const result = await response.json();
            
            // Reload relationships
            await loadRelationships();
            
            // Show summary notification
            if (result.summary) {
                const { created_count, failed_count } = result.summary;
                if (failed_count === 0) {
                    showNotification(`Successfully imported ${created_count} relationships`, 'success');
                } else if (created_count === 0) {
                    showNotification(`Failed to import relationships: ${result.failed[0]?.error || 'Unknown error'}`, 'danger');
                } else {
                    showNotification(`Imported ${created_count} relationships (${failed_count} failed)`, 'warning');
                }
            } else {
                showNotification('Relationships imported successfully', 'success');
            }
        } catch (error) {
            console.error('Error importing entries:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function deleteRelationship(relationshipId, entryTitle) {
        console.log('deleteRelationship called:', { relationshipId, entryTitle });
        
        if (!confirm(`Delete relationship with "${entryTitle}"?`)) {
            console.log('User cancelled deletion');
            return;
        }
        
        // Get the related entry ID before deletion (for note binding cleanup)
        const row = document.querySelector(`[data-relationship-id="${relationshipId}"]`)?.closest('tr');
        const bindNotesBtn = row?.querySelector('.btn-bind-notes');
        const relatedEntryId = bindNotesBtn ? bindNotesBtn.getAttribute('data-entry-id') : null;
        
        console.log('Sending DELETE request to:', `/api/relationships/${relationshipId}`);
        
        try {
            const response = await fetch(`/api/relationships/${relationshipId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error('Failed to delete relationship');
            }
            
            // Clean up note binding if it exists for this entry
            if (relatedEntryId) {
                const entryIdInt = parseInt(relatedEntryId);
                
                // Check if there are any remaining relationships with this entry
                try {
                    // Call the cleanup API to remove note bindings if no relationships remain
                    const cleanupResponse = await fetch('/api/note_bindings/cleanup', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            source_entry_id: entryId,
                            target_entry_id: entryIdInt
                        })
                    });
                    
                    if (cleanupResponse.ok) {
                        const cleanupResult = await cleanupResponse.json();
                        
                        if (cleanupResult.removed) {
                            // Remove from local state
                            noteBingingState.delete(entryIdInt);
                            
                            console.log(`Removed note binding for deleted relationship with entry ${entryTitle} (ID: ${entryIdInt})`);
                            
                            // Update button state if it still exists
                            updateBindNotesButtonState(entryIdInt, false);
                        } else {
                            console.log(`Note binding automatically removed for ${entryTitle} since relationship was deleted`);
                        }
                    } else {
                        console.error('Failed to cleanup note bindings:', cleanupResponse.statusText);
                    }
                } catch (cleanupError) {
                    console.error('Error cleaning up note bindings:', cleanupError);
                }
            }
            
            await loadRelationships();
            showNotification('Relationship deleted', 'success');
        } catch (error) {
            console.error('Error deleting relationship:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function editQuantity(relationshipId, currentQuantity, currentUnit) {
        const newQuantity = prompt('Enter quantity:', currentQuantity);
        if (newQuantity === null) return;
        
        const newUnit = prompt('Enter unit:', currentUnit);
        if (newUnit === null) return;
        
        try {
            const response = await fetch(`/api/relationships/${relationshipId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    quantity: parseFloat(newQuantity) || null,
                    unit: newUnit || null
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to update quantity/unit');
            }
            
            await loadRelationships();
            showNotification('Quantity/unit updated', 'success');
        } catch (error) {
            console.error('Error updating quantity:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    function showNotification(message, type) {
        // Simple notification - you can enhance this
        const alertClass = type === 'success' ? 'alert-success' : 'alert-danger';
        const icon = type === 'success' ? 'check-circle' : 'exclamation-triangle';
        
        const notification = document.createElement('div');
        notification.className = `alert ${alertClass} alert-dismissible fade show position-fixed top-0 start-50 translate-middle-x mt-3`;
        notification.style.zIndex = '9999';
        notification.innerHTML = `
            <i class="fas fa-${icon} me-2"></i>
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Toggle visibility of empty relationship cards
    window['toggleEmptyRelationships' + sectionUniqueId] = function() {
        const emptyCards = document.querySelectorAll('#relationshipsSection' + sectionUniqueId + ' .empty-relationship-card');
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + sectionUniqueId);
        const toggleText = toggleBtn.querySelector('.toggle-text');
        const toggleIcon = toggleBtn.querySelector('i');
        
        // Check current state - if any empty card is hidden, we're in "hidden" state
        const isHidden = Array.from(emptyCards).some(card => card.style.display === 'none');
        
        emptyCards.forEach(card => {
            if (isHidden) {
                // Show the card
                card.style.display = 'block';
                card.style.opacity = '0';
                card.style.maxHeight = '0';
                card.style.marginBottom = '0';
                // Trigger reflow
                card.offsetHeight;
                // Animate in
                setTimeout(() => {
                    card.style.opacity = '1';
                    card.style.maxHeight = '1000px';
                    card.style.marginBottom = '1rem';
                }, 10);
            } else {
                // Hide the card
                card.style.opacity = '0';
                card.style.maxHeight = '0';
                card.style.marginBottom = '0';
                setTimeout(() => {
                    card.style.display = 'none';
                }, 300); // Match transition duration
            }
        });
        
        // Update button text and icon
        if (isHidden) {
            toggleText.textContent = 'Hide Empty';
            toggleIcon.className = 'fas fa-eye-slash me-1';
        } else {
            toggleText.textContent = 'Show Empty';
            toggleIcon.className = 'fas fa-eye me-1';
        }
    };
    
    // Hierarchy view functionality
    let hierarchyLoaded = false;
    
    async function loadHierarchy() {
        if (hierarchyLoaded) return;
        
        const loadingDiv = document.getElementById('hierarchyLoading' + sectionUniqueId);
        const contentDiv = document.getElementById('hierarchyContent' + sectionUniqueId);
        
        if (!loadingDiv || !contentDiv) return;
        
        loadingDiv.style.display = 'flex';
        contentDiv.innerHTML = '';
        
        try {
            const response = await fetch(`/api/entries/${entryId}/relationships/hierarchy`);
            const data = await response.json();
            
            if (!response.ok) {
                throw new Error(data.error || 'Failed to load hierarchy');
            }
            
            const hierarchy = data.hierarchy || [];
            renderHierarchyTree(hierarchy, contentDiv);
            hierarchyLoaded = true;
            
        } catch (error) {
            console.error('Error loading hierarchy:', error);
            contentDiv.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading hierarchy: ${escapeHtml(error.message)}
                    <button class="btn btn-sm btn-outline-danger ms-3" onclick="retryLoadHierarchy${entryId}()">
                        <i class="fas fa-redo me-1"></i>Retry
                    </button>
                </div>
            `;
        } finally {
            loadingDiv.style.display = 'none';
        }
    }
    
    function renderHierarchyTree(hierarchy, container) {
        console.log('renderHierarchyTree called with:', hierarchy);
        console.log('Hierarchy length:', hierarchy ? hierarchy.length : 0);
        console.log('First node:', hierarchy && hierarchy.length > 0 ? hierarchy[0] : null);
        
        if (!hierarchy || hierarchy.length === 0) {
            container.innerHTML = `
                <div class="hierarchy-empty-state">
                    <i class="fas fa-sitemap"></i>
                    <p class="text-muted">No hierarchical relationships found</p>
                    <small class="text-muted d-block mb-2">Parent-child relationships will appear here</small>
                    <a href="/manage_relationships" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-cog me-1"></i>Configure Relationship Definitions
                    </a>
                </div>
            `;
            return;
        }
        
        // Build HTML for each relationship type tree
        let treeHtml = '';
        if (hierarchy.length > 1) {
            console.log('Multiple trees detected:', hierarchy.length);
            // Multiple relationship types - show separate trees with headers
            treeHtml = hierarchy.map((rootNode, index) => {
                const relationshipTypeName = rootNode.relationship_type_name || `Relationship ${index + 1}`;
                console.log(`Tree ${index + 1}: ${relationshipTypeName}`);
                const treeContent = renderTreeNode(rootNode, 0);
                return `
                    <div class="relationship-tree-section mb-4">
                        <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                            <h6 class="text-primary mb-0">
                                <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                            </h6>
                        </div>
                        <div class="relationship-tree">${treeContent}</div>
                    </div>
                `;
            }).join('<hr class="my-3">');
        } else {
            // Single relationship type tree
            const rootNode = hierarchy[0];
            const relationshipTypeName = rootNode.relationship_type_name;
            console.log('Single tree - relationship type name:', relationshipTypeName);
            console.log('Root node:', rootNode);
            const headerHtml = relationshipTypeName ? `
                <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                    <h6 class="text-primary mb-0">
                        <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                    </h6>
                </div>
            ` : '';
            console.log('Header HTML:', headerHtml);
            treeHtml = `${headerHtml}<div class="relationship-tree">${renderTreeNode(rootNode, 0)}</div>`;
            console.log('Final tree HTML length:', treeHtml.length);
        }
        
        container.innerHTML = treeHtml;
        
        // Initialize tree toggles after rendering
        initializeTreeToggles();
    }
    
    function renderTreeNode(node, level) {
        const isTarget = node.is_target || false;  // The entry we're viewing
        const hasChildren = node.children && node.children.length > 0;
        
        const nodeClasses = ['tree-node-content'];
        if (isTarget) nodeClasses.push('current-entry');
        
        let html = `
            <div class="tree-node level-${level}" data-entry-id="${node.id}" style="padding-left: ${level * 20}px;">
                <div class="${nodeClasses.join(' ')}">
        `;
        
        // Toggle button or spacer
        if (hasChildren) {
            html += `
                <button class="tree-toggle-btn" data-node-id="${node.id}">
                    <i class="fas fa-chevron-down"></i>
                </button>
            `;
        } else {
            html += `<span class="tree-spacer"></span>`;
        }
        
        // Entry type icon
        html += `
            <span class="tree-entry-type" 
                  style="color: ${node.entry_type.color || '#6c757d'};"
                  title="${escapeHtml(node.entry_type.label)}">
                <i class="${node.entry_type.icon || 'fas fa-link'}"></i>
            </span>
        `;
        
        // Direction indicator (parent/child arrow)
        const direction = node.direction || 'unknown';
        if (direction === 'ancestor') {
            html += `
                <span class="tree-direction-icon" title="Parent/Ancestor">
                    <i class="fas fa-arrow-up text-primary"></i>
                </span>
            `;
        } else if (direction === 'descendant') {
            html += `
                <span class="tree-direction-icon" title="Child/Descendant">
                    <i class="fas fa-arrow-down text-success"></i>
                </span>
            `;
        }
        
        // Entry title and link
        html += `
            <a href="/entry/${node.id}" 
               class="tree-entry-link ${isTarget ? 'fw-bold' : ''}"
               target="_blank">
                ${escapeHtml(node.title)}
        `;
        
        // Badge for current/target entry
        if (isTarget) {
            html += `<span class="badge bg-success ms-2">Current</span>`;
        }
        html += `</a>`;
        
        // Status badge with dynamic color
        if (node.status) {
            const statusColor = node.status_color || '#6c757d';
            const textColor = getContrastColor(statusColor);
            html += `
                <span class="badge ms-2" style="background-color: ${statusColor}; color: ${textColor};">
                    ${escapeHtml(node.status)}
                </span>
            `;
        }
        
        // Relationship type label
        if (node.relationship_type) {
            html += `
                <small class="text-muted ms-2">
                    <i class="fas fa-link"></i> ${escapeHtml(node.relationship_type)}
                </small>
            `;
        }
        
        html += `</div>`; // Close tree-node-content
        
        // Children (recursive)
        if (hasChildren) {
            html += `<div class="tree-children" data-parent-id="${node.id}">`;
            for (const child of node.children) {
                html += renderTreeNode(child, level + 1);
            }
            html += `</div>`;
        }
        
        html += `</div>`; // Close tree-node
        
        return html;
    }
    
    function initializeTreeToggles() {
        const toggleButtons = document.querySelectorAll('.tree-toggle-btn');
        
        toggleButtons.forEach(button => {
            // Remove existing listeners by cloning
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            newButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const nodeId = this.dataset.nodeId;
                const childrenDiv = document.querySelector(`.tree-children[data-parent-id="${nodeId}"]`);
                const icon = this.querySelector('i');
                
                if (childrenDiv) {
                    childrenDiv.classList.toggle('collapsed');
                    
                    if (childrenDiv.classList.contains('collapsed')) {
                        icon.style.transform = 'rotate(-90deg)';
                    } else {
                        icon.style.transform = 'rotate(0deg)';
                    }
                }
            });
        });
    }
    
    // Retry function for hierarchy loading
    window['retryLoadHierarchy' + entryId] = function() {
        hierarchyLoaded = false;
        loadHierarchy();
    };
    
    // Setup tab event listeners
    function setupTabListeners() {
        const hierarchyTab = document.getElementById('hierarchyTab' + sectionUniqueId + '-tab');
        
        if (hierarchyTab) {
            hierarchyTab.addEventListener('shown.bs.tab', function() {
                loadHierarchy();
            });
        }
    }
    
    // ========== Grid Reordering Functionality ==========
    let reorderMode = false;
    let draggedElement = null;
    
    function initializeDragAndDrop() {
        const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
        if (!container) return;
        
        const cards = container.querySelectorAll('.relationship-type-card');
        
        cards.forEach(card => {
            const handle = card.querySelector('.card-drag-handle');
            
            if (!handle) return;
            
            // Make the handle draggable
            handle.addEventListener('mousedown', function(e) {
                if (!reorderMode) return;
                card.setAttribute('draggable', 'true');
            });
            
            handle.addEventListener('mouseup', function(e) {
                card.setAttribute('draggable', 'false');
            });
            
            // Drag start
            card.addEventListener('dragstart', function(e) {
                if (!reorderMode) {
                    e.preventDefault();
                    return;
                }
                draggedElement = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            
            // Drag end
            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.setAttribute('draggable', 'false');
                
                // Remove all drag-over classes
                const allCards = container.querySelectorAll('.relationship-type-card');
                allCards.forEach(c => c.classList.remove('drag-over'));
                
                // Save the new order
                saveGridOrder();
            });
            
            // Drag over
            card.addEventListener('dragover', function(e) {
                if (!reorderMode || !draggedElement) return;
                
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const afterElement = getDragAfterElement(container, e.clientY);
                if (afterElement == null) {
                    container.appendChild(draggedElement);
                } else {
                    container.insertBefore(draggedElement, afterElement);
                }
            });
            
            // Drag enter
            card.addEventListener('dragenter', function(e) {
                if (!reorderMode || this === draggedElement) return;
                this.classList.add('drag-over');
            });
            
            // Drag leave
            card.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });
        });
    }
    
    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.relationship-type-card:not(.dragging):not(.empty-relationship-card)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    async function saveGridOrder() {
        const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
        if (!container) return;
        
        const cards = container.querySelectorAll('.relationship-type-card:not(.empty-relationship-card)');
        const orderList = [];
        
        cards.forEach((card, index) => {
            const definitionId = parseInt(card.dataset.definitionId);
            orderList.push({
                definition_id: definitionId,
                order: index
            });
        });
        
        try {
            const response = await fetch(`/api/entry_types/${currentEntryTypeId}/relationship_grid_order`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ order: orderList })
            });
            
            if (response.ok) {
                console.log('Grid order saved successfully for entry type');
                // Show a success message
                showNotification('Grid order saved for all entries of this type', 'success');
                // Update the custom order cache
                orderList.forEach(item => {
                    customGridOrder[item.definition_id] = item.order;
                });
            } else {
                console.error('Failed to save grid order');
                showNotification('Failed to save grid order', 'danger');
            }
        } catch (error) {
            console.error('Error saving grid order:', error);
            showNotification('Error saving grid order', 'danger');
        }
    }
    
    // Toggle reorder mode
    window['toggleReorderMode' + sectionUniqueId] = function() {
        reorderMode = !reorderMode;
        
        const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
        const btn = document.getElementById('toggleReorderMode' + sectionUniqueId);
        const btnText = btn.querySelector('.reorder-text');
        const handles = container.querySelectorAll('.card-drag-handle');
        
        if (reorderMode) {
            container.classList.add('reorder-mode-active');
            btnText.textContent = 'Done';
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-primary');
            handles.forEach(h => h.style.display = 'inline-block');
        } else {
            container.classList.remove('reorder-mode-active');
            btnText.textContent = 'Reorder';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-outline-primary');
            handles.forEach(h => h.style.display = 'none');
        }
    };
    
    // ========== Note Binding Functions ==========
    
    // Load note binding state from database
    async function loadNoteBindingState() {
        try {
            const response = await fetch(`/api/note_bindings?entry_id=${entryId}`);
            if (response.ok) {
                const bindings = await response.json();
                
                // Clear existing state
                noteBingingState.clear();
                
                // Populate state from database
                bindings.forEach(binding => {
                    if (binding.enabled) {
                        noteBingingState.set(binding.target_entry_id, true);
                    }
                });
                
                // Update button states
                noteBingingState.forEach((isEnabled, entryId) => {
                    updateBindNotesButtonState(entryId, isEnabled);
                });
                
                console.log('Loaded note binding state from database:', noteBingingState);
            } else {
                console.error('Failed to load note binding state:', response.statusText);
                noteBingingState = new Map();
            }
        } catch (error) {
            console.error('Error loading note binding state:', error);
            noteBingingState = new Map();
        }
    }
    
    // Show Bind Notes Modal
    function showBindNotesModal(targetEntryId, targetEntryTitle) {
        const modalId = 'bindNotesModal_' + entryId;
        
        // Remove existing modal if it exists
        const existingModal = document.getElementById(modalId);
        if (existingModal) {
            existingModal.remove();
        }
        
        const currentBindingState = noteBingingState.get(parseInt(targetEntryId)) || false;
        
        const modalHtml = `
            <div class="modal fade" id="${modalId}" tabindex="-1" aria-labelledby="${modalId}Label" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="${modalId}Label">
                                <i class="fas fa-link me-2"></i>
                                Bind Notes: ${escapeHtml(targetEntryTitle)}
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                <strong>Note Binding:</strong> When enabled, any new notes created in this entry will automatically be associated with <strong>${escapeHtml(targetEntryTitle)}</strong>.
                            </div>
                            
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="bindNotesToggle_${modalId}" ${currentBindingState ? 'checked' : ''}>
                                <label class="form-check-label" for="bindNotesToggle_${modalId}">
                                    <strong>Enable automatic note binding to ${escapeHtml(targetEntryTitle)}</strong>
                                </label>
                            </div>
                            
                            <div class="border-top pt-3">
                                <h6><i class="fas fa-question-circle me-2"></i>How it works:</h6>
                                <ul class="small text-muted mb-0">
                                    <li>When enabled, new notes in this entry will automatically include ${escapeHtml(targetEntryTitle)} in their associations</li>
                                    <li>You can still manually add/remove associations when creating notes</li>
                                    <li>This setting only affects new notes - existing notes are not changed</li>
                                    <li>You can disable this at any time</li>
                                </ul>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-primary" id="saveBindingBtn_${modalId}">
                                <i class="fas fa-save me-1"></i>Save Setting
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = new bootstrap.Modal(document.getElementById(modalId));
        modal.show();
        
        // Add event listeners
        const saveBtn = document.getElementById('saveBindingBtn_' + modalId);
        const toggle = document.getElementById('bindNotesToggle_' + modalId);
        
        saveBtn.addEventListener('click', async function() {
            const isEnabled = toggle.checked;
            const originalText = saveBtn.innerHTML;
            
            try {
                // Show loading state
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving...';
                
                // Save to database via API
                const response = await fetch('/api/note_bindings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        source_entry_id: entryId,
                        target_entry_id: parseInt(targetEntryId),
                        enabled: isEnabled
                    })
                });
                
                if (response.ok) {
                    // Update local state
                    noteBingingState.set(parseInt(targetEntryId), isEnabled);
                    
                    // Update UI feedback
                    updateBindNotesButtonState(targetEntryId, isEnabled);
                    
                    // Show success message
                    const alertHtml = `
                        <div class="alert alert-success alert-dismissible fade show" role="alert">
                            <i class="fas fa-check-circle me-2"></i>
                            Note binding ${isEnabled ? 'enabled' : 'disabled'} for ${escapeHtml(targetEntryTitle)}
                            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                        </div>
                    `;
                    
                    // Add alert to the page
                    const alertContainer = document.querySelector('.container-fluid');
                    if (alertContainer) {
                        alertContainer.insertAdjacentHTML('afterbegin', alertHtml);
                        
                        // Auto-dismiss after 3 seconds
                        setTimeout(() => {
                            const alert = alertContainer.querySelector('.alert-success');
                            if (alert) {
                                alert.remove();
                            }
                        }, 3000);
                    }
                    
                    // Close modal
                    modal.hide();
                    
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to save note binding');
                }
                
            } catch (error) {
                console.error('Error saving note binding:', error);
                alert(`Error saving note binding: ${error.message}`);
            } finally {
                // Restore button state
                saveBtn.disabled = false;
                saveBtn.innerHTML = originalText;
            }
        });
        
        // Clean up modal when closed
        document.getElementById(modalId).addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    }
    
    // Update bind notes button visual state
    function updateBindNotesButtonState(targetEntryId, isEnabled) {
        const button = document.querySelector(`[data-entry-id="${targetEntryId}"].btn-bind-notes`);
        if (button) {
            const icon = button.querySelector('i');
            if (isEnabled) {
                // Enabled state - solid blue button with link icon
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-primary');
                button.title = 'Notes binding enabled - click to configure';
                if (icon) {
                    icon.classList.remove('fa-link');
                    icon.classList.add('fa-link', 'fa-solid');
                }
            } else {
                // Disabled state - outline button with link icon
                button.classList.remove('btn-primary');
                button.classList.add('btn-outline-primary');
                button.title = 'Bind notes from this entry';
                if (icon) {
                    icon.classList.remove('fa-solid');
                    icon.classList.add('fa-link');
                }
            }
        }
    }
    
    // ========== End Note Binding Functions ==========
    
    // Initialize on load
    loadRelationships();
    setupTabListeners();
    loadNoteBindingState();
    
    // Show reorder button when cards are loaded
    const observer = new MutationObserver(function(mutations) {
        const container = document.getElementById('groupedViewContainer' + sectionUniqueId);
        const reorderBtn = document.getElementById('toggleReorderMode' + sectionUniqueId);
        
        if (container && reorderBtn) {
            const cards = container.querySelectorAll('.relationship-type-card:not(.empty-relationship-card)');
            if (cards.length > 1) {
                reorderBtn.style.display = 'inline-block';
                initializeDragAndDrop();
                observer.disconnect();
            }
        }
    });
    
    const containerEl = document.getElementById('groupedViewContainer' + sectionUniqueId);
    if (containerEl) {
        observer.observe(containerEl, { childList: true, subtree: true });
    }
})();
</script>
