{# Relationships Section for Entry Detail V2 - With Section-Level Configuration #}
{# Expected context: section_id, section_config, entry #}
{% set section_uid = section_id|default('default') %}
{% set config = section_config|default({}) %}
{# Parse visible/hidden relationship types from config #}
{% set visible_rel_types = config.get('visible_relationship_types', [])|list %}
{% set hidden_rel_types = config.get('hidden_relationship_types', [])|list %}

<div class="relationships-section" id="relationshipsSection{{ section_uid }}">
  
  <!-- Section Header -->
  <div class="section-header mb-3 d-flex justify-content-between align-items-center">
    <h5 class="mb-0">
      <i class="fas fa-link me-2"></i>
      Related Records
    </h5>
    <div class="d-flex gap-2">
      <button id="toggleReorderMode{{ section_uid }}" 
              class="btn btn-sm btn-outline-primary" 
              onclick="toggleReorderMode{{ section_uid }}()"
              title="Reorder relationship type cards"
              style="display: none;">
        <i class="fas fa-grip-vertical me-1"></i>
        <span class="reorder-text">Reorder</span>
      </button>
      <button id="toggleEmptyRelationships{{ section_uid }}" 
              class="btn btn-sm btn-outline-secondary" 
              onclick="toggleEmptyRelationships{{ section_uid }}()"
              title="Show/hide relationship types with no records"
              style="display: none;">
        <i class="fas fa-eye me-1"></i>
        <span class="toggle-text">Show Empty</span>
      </button>
    </div>
  </div>

  <!-- Loading State -->
  <div id="relationshipsLoading{{ section_uid }}" class="text-center py-4">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2 text-muted">Loading relationships...</p>
  </div>

  <!-- Section Content -->
  <div id="relatedRecordsContainer{{ section_uid }}" style="display: none;">
    
    <!-- Tabs Navigation -->
    <ul class="nav nav-tabs mb-3" id="relationshipsTabs{{ section_uid }}" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="groupedTab{{ section_uid }}-tab" data-bs-toggle="tab" 
                data-bs-target="#groupedTab{{ section_uid }}" type="button" role="tab" 
                aria-controls="groupedTab{{ section_uid }}" aria-selected="true">
          <i class="fas fa-th-list me-1"></i> Grouped View
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="hierarchyTab{{ section_uid }}-tab" data-bs-toggle="tab" 
                data-bs-target="#hierarchyTab{{ section_uid }}" type="button" role="tab" 
                aria-controls="hierarchyTab{{ section_uid }}" aria-selected="false">
          <i class="fas fa-sitemap me-1"></i> Hierarchy View
        </button>
      </li>
    </ul>
    
    <!-- Tab Content -->
    <div class="tab-content" id="relationshipsTabContent{{ section_uid }}">
      
      <!-- Grouped View Tab (default) -->
      <div class="tab-pane fade show active" id="groupedTab{{ section_uid }}" role="tabpanel" 
           aria-labelledby="groupedTab{{ section_uid }}-tab">
        <div id="groupedViewContainer{{ section_uid }}">
          <!-- Will be populated via JavaScript with cards for each relationship type -->
        </div>
      </div>
      
      <!-- Hierarchy View Tab -->
      <div class="tab-pane fade" id="hierarchyTab{{ section_uid }}" role="tabpanel" 
           aria-labelledby="hierarchyTab{{ section_uid }}-tab">
        
        <div id="hierarchyLoading{{ section_uid }}" class="text-center py-4" style="display: none;">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2 text-muted">Loading hierarchy...</p>
        </div>
        
        <div id="hierarchyContent{{ section_uid }}">
          <!-- Will be populated via JavaScript when tab is activated -->
        </div>
      </div>
      
    </div>
  </div>

</div>

<style>
/* Relationship cards styling with theme support */
.relationship-type-card {
    margin-bottom: 1rem;
    border: 1px solid var(--theme-border-color, var(--bs-border-color));
    border-radius: 0.5rem;
    overflow: visible;
    background-color: var(--theme-card-bg, var(--bs-body-bg));
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease, transform 0.2s ease, opacity 0.3s ease, max-height 0.3s ease;
}

/* Empty relationship cards - hidden by default */
.empty-relationship-card {
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    margin-bottom: 0;
    transition: opacity 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
}

.empty-relationship-card .card-header {
    background-color: var(--bs-light);
    opacity: 0.85;
}

.relationship-type-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
}

.relationship-type-card .card-header {
    background-color: var(--bs-secondary-bg);
    border-bottom: 1px solid var(--bs-border-color);
    padding: 0.75rem 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    overflow: visible;
    gap: 0.5rem;
}

.card-drag-handle {
    cursor: grab;
    color: var(--bs-secondary);
}

.card-drag-handle:active {
    cursor: grabbing;
}

/* Drag and drop states */
.relationship-type-card.dragging {
    opacity: 0.5;
}

.relationship-type-card.drag-over {
    border-top: 3px solid var(--bs-primary);
}

.reorder-mode-active {
    padding: 0.5rem;
    border: 2px dashed var(--bs-border-color);
    border-radius: 0.5rem;
}

/* Hierarchy Tree Styles */
.relationship-tree {
    padding: 1rem 0;
}

.tree-node {
    margin-bottom: 0.25rem;
}

.tree-node-content {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    border-radius: 0.25rem;
    transition: background-color 0.15s ease;
}

.tree-node-content:hover {
    background-color: var(--theme-hover-bg, var(--bs-secondary-bg));
}

.tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.1);
    border-left: 3px solid #0d6efd;
}

[data-bs-theme="dark"] .tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.2);
}

.tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.1);
    border-left: 3px solid #0dcaf0;
}

[data-bs-theme="dark"] .tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.15);
}

.tree-toggle-btn {
    background: none;
    border: none;
    padding: 0.25rem;
    margin-right: 0.5rem;
    cursor: pointer;
    color: var(--bs-secondary);
    transition: transform 0.2s ease, color 0.2s ease;
    width: 20px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.tree-toggle-btn:hover {
    color: var(--bs-primary);
}

.tree-toggle-btn i {
    transition: transform 0.2s ease;
}

.tree-spacer {
    display: inline-block;
    width: 20px;
    margin-right: 0.5rem;
}

.tree-entry-type {
    margin-right: 0.5rem;
    font-size: 1rem;
}

.tree-direction-icon {
    margin-right: 0.5rem;
    font-size: 0.875rem;
    display: inline-flex;
    align-items: center;
}

.tree-direction-icon i {
    font-size: 0.75rem;
}

.tree-entry-link {
    color: var(--bs-body-color);
    text-decoration: none;
    margin-right: 0.5rem;
    transition: color 0.2s ease;
}

.tree-entry-link:hover {
    color: var(--bs-primary);
    text-decoration: underline;
}

.tree-children {
    overflow: hidden;
    max-height: 5000px;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    opacity: 1;
}

.tree-children.collapsed {
    max-height: 0;
    opacity: 0;
}

.status-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    background-color: var(--bs-secondary);
    color: white;
}

/* Empty state for hierarchy */
.hierarchy-empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--bs-secondary-color);
}

.hierarchy-empty-state i {
    font-size: 3rem;
    opacity: 0.25;
    margin-bottom: 1rem;
    display: block;
}
</style>

<script>
// Relationships Section with Configuration Support - Version 2025-11-08
(function() {
    const sectionUid = '{{ section_uid }}';
    const entryId = {{ entry.id }};
    const currentEntryTypeId = {{ entry.entry_type_id }};
    
    // Section-level configuration
    const sectionConfig = {
        visibleRelTypes: {{ visible_rel_types|tojson|safe }},
        hiddenRelTypes: {{ hidden_rel_types|tojson|safe }}
    };
    
    console.log('=== Relationships Section (Configurable) Loaded ===');
    console.log('Section UID:', sectionUid);
    console.log('Entry ID:', entryId);
    console.log('Config:', sectionConfig);
    
    let relationshipDefinitions = [];
    let customGridOrder = {};
    
    // Utility function: Get contrasting text color for a background color
    function getContrastColor(hexColor) {
        if (!hexColor) return '#fff';
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 128 ? '#000' : '#fff';
    }
    
    // Utility function: Escape HTML to prevent XSS
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Load relationships on page load
    loadRelationships();
    
    async function loadRelationships() {
        const loadingEl = document.getElementById('relationshipsLoading' + sectionUid);
        const containerEl = document.getElementById('relatedRecordsContainer' + sectionUid);
        
        try {
            // Fetch relationship definitions
            const defsResponse = await fetch('/api/relationship_definitions');
            const definitions = await defsResponse.json();
            
            // Filter to relevant definitions for this entry type
            let filteredDefs = definitions.filter(def => 
                def.entry_type_id_from === currentEntryTypeId || 
                def.entry_type_id_to === currentEntryTypeId
            );
            
            // Apply section-level filtering
            if (sectionConfig.visibleRelTypes.length > 0) {
                // If visible list is specified, only show those
                filteredDefs = filteredDefs.filter(def => 
                    sectionConfig.visibleRelTypes.includes(def.id)
                );
            } else if (sectionConfig.hiddenRelTypes.length > 0) {
                // If hidden list is specified, filter them out
                filteredDefs = filteredDefs.filter(def => 
                    !sectionConfig.hiddenRelTypes.includes(def.id)
                );
            }
            
            relationshipDefinitions = filteredDefs;
            
            // Fetch existing relationships
            const relsResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relsResponse.json();
            
            // Fetch custom grid order for this SECTION (not entry type)
            try {
                const orderResponse = await fetch(`/api/sections/{{ section_id }}/relationship_grid_order`);
                customGridOrder = await orderResponse.json();
            } catch (error) {
                console.warn('Could not load section grid order, using default:', error);
                customGridOrder = {};
            }
            
            // Group relationships by definition ID
            const groupedRelationships = {};
            relationships.forEach(rel => {
                if (!groupedRelationships[rel.definition_id]) {
                    groupedRelationships[rel.definition_id] = [];
                }
                groupedRelationships[rel.definition_id].push(rel);
            });
            
            // Sort definitions by custom order if available
            const sortedDefinitions = [...relationshipDefinitions].sort((a, b) => {
                const orderA = customGridOrder[a.id] !== undefined ? customGridOrder[a.id] : 999;
                const orderB = customGridOrder[b.id] !== undefined ? customGridOrder[b.id] : 999;
                return orderA - orderB;
            });
            
            // Render the cards
            renderRelationshipCards(sortedDefinitions, groupedRelationships);
            
            loadingEl.style.display = 'none';
            containerEl.style.display = 'block';
            
        } catch (error) {
            console.error('Error loading relationships:', error);
            loadingEl.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading relationships: ${error.message}
                </div>
            `;
        }
    }
    
    function renderRelationshipCards(definitions, groupedRelationships) {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        
        if (!container) {
            console.error('Grouped view container not found');
            return;
        }
        
        if (definitions.length === 0) {
            container.innerHTML = `
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>
                    No relationship types configured for this section.
                </div>
            `;
            return;
        }
        
        let html = '';
        let hasEmptyCards = false;
        
        definitions.forEach(def => {
            const isFromSide = def.entry_type_id_from === currentEntryTypeId;
            const relationships = groupedRelationships[def.id] || [];
            
            const displayLabel = isFromSide ? def.label_from_side : def.label_to_side;
            const relevantCardinality = isFromSide ? def.cardinality_from : def.cardinality_to;
            const canAddMore = relevantCardinality === -1 || relationships.length < relevantCardinality;
            
            const isEmpty = relationships.length === 0;
            if (isEmpty) hasEmptyCards = true;
            
            html += `
                <div class="relationship-type-card card ${isEmpty ? 'empty-relationship-card' : ''}" 
                     data-definition-id="${def.id}"
                     style="${isEmpty ? 'display: none;' : ''}">
                    <div class="card-header">
                        <div class="d-flex align-items-center gap-2">
                            <i class="fas fa-grip-vertical card-drag-handle" 
                               style="display: none;"
                               title="Drag to reorder"></i>
                            <h6 class="mb-0">${escapeHtml(displayLabel || def.name)}</h6>
                            <span class="badge bg-secondary">${relationships.length}</span>
                        </div>
                        <div class="d-flex gap-2 align-items-center">
                            <button class="btn btn-sm btn-primary" 
                                    onclick="openAddRelationshipModal${sectionUid}(${def.id}, '${escapeHtml(displayLabel || def.name)}')"
                                    ${!canAddMore ? 'disabled' : ''}
                                    title="${canAddMore ? 'Add ' + (displayLabel || def.name) : 'Maximum entries reached'}">
                                <i class="fas fa-plus me-1"></i>Add
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        ${relationships.length > 0 ? `
                            <table class="table table-sm table-hover mb-0">
                                <tbody>
                                    ${relationships.map(rel => renderRelationshipRow(rel, def)).join('')}
                                </tbody>
                            </table>
                        ` : `
                            <p class="text-muted mb-0">No ${escapeHtml(displayLabel || def.name).toLowerCase()} yet.</p>
                        `}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        
        // Show/hide toggle button if there are empty cards
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + sectionUid);
        if (toggleBtn && hasEmptyCards) {
            toggleBtn.style.display = 'block';
        }
        
        // Show reorder button if there are 2+ definitions
        const reorderBtn = document.getElementById('toggleReorderMode' + sectionUid);
        if (reorderBtn && definitions.length >= 2) {
            reorderBtn.style.display = 'block';
        }
        
        // Initialize drag and drop functionality
        initializeDragAndDrop();
    }
    
    function renderRelationshipRow(rel, def) {
        return `
            <tr>
                <td>
                    <a href="/entry/${rel.related_entry_id}" class="text-decoration-none">
                        <span class="badge" style="background-color: ${rel.related_entry_status_color};">
                            ${escapeHtml(rel.related_entry_status || 'N/A')}
                        </span>
                        ${escapeHtml(rel.related_entry_title)}
                    </a>
                    ${rel.quantity ? `<span class="text-muted ms-2">(${rel.quantity}${rel.unit ? ' ' + rel.unit : ''})</span>` : ''}
                </td>
                <td class="text-end">
                    <button class="btn btn-sm btn-outline-danger" 
                            onclick="deleteRelationship${sectionUid}(${rel.relationship_id})">
                        <i class="fas fa-trash"></i>
                    </button>
                </td>
            </tr>
        `;
    }
    
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // ========== Grid Reordering Functionality ==========
    let reorderMode = false;
    let draggedElement = null;
    
    function initializeDragAndDrop() {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const cards = container.querySelectorAll('.relationship-type-card');
        
        cards.forEach(card => {
            const handle = card.querySelector('.card-drag-handle');
            
            if (!handle) return;
            
            // Make the handle draggable
            handle.addEventListener('mousedown', function(e) {
                if (!reorderMode) return;
                card.setAttribute('draggable', 'true');
            });
            
            handle.addEventListener('mouseup', function(e) {
                card.setAttribute('draggable', 'false');
            });
            
            // Drag start
            card.addEventListener('dragstart', function(e) {
                if (!reorderMode) {
                    e.preventDefault();
                    return;
                }
                draggedElement = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            
            // Drag end
            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.setAttribute('draggable', 'false');
                
                // Remove all drag-over classes
                const allCards = container.querySelectorAll('.relationship-type-card');
                allCards.forEach(c => c.classList.remove('drag-over'));
                
                // Save the new order
                saveGridOrder();
            });
            
            // Drag over
            card.addEventListener('dragover', function(e) {
                if (!reorderMode || !draggedElement) return;
                
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const afterElement = getDragAfterElement(container, e.clientY);
                if (afterElement == null) {
                    container.appendChild(draggedElement);
                } else {
                    container.insertBefore(draggedElement, afterElement);
                }
            });
            
            // Drag enter
            card.addEventListener('dragenter', function(e) {
                if (!reorderMode || this === draggedElement) return;
                this.classList.add('drag-over');
            });
            
            // Drag leave
            card.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });
        });
    }
    
    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.relationship-type-card:not(.dragging):not(.empty-relationship-card)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    async function saveGridOrder() {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const cards = container.querySelectorAll('.relationship-type-card:not(.empty-relationship-card)');
        const orderList = [];
        
        cards.forEach((card, index) => {
            const definitionId = parseInt(card.dataset.definitionId);
            orderList.push({
                definition_id: definitionId,
                order: index
            });
        });
        
        try {
            const response = await fetch(`/api/sections/{{ section_id }}/relationship_grid_order`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ order: orderList })
            });
            
            if (response.ok) {
                console.log('Grid order saved successfully for section {{ section_id }}');
                showNotification('Grid order saved for this section', 'success');
                // Update the custom order cache
                orderList.forEach(item => {
                    customGridOrder[item.definition_id] = item.order;
                });
            } else {
                console.error('Failed to save grid order');
                showNotification('Failed to save grid order', 'danger');
            }
        } catch (error) {
            console.error('Error saving grid order:', error);
            showNotification('Error saving grid order', 'danger');
        }
    }
    
    // Toggle reorder mode
    window['toggleReorderMode' + sectionUid] = function() {
        reorderMode = !reorderMode;
        
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        const btn = document.getElementById('toggleReorderMode' + sectionUid);
        const btnText = btn.querySelector('.reorder-text');
        const handles = container.querySelectorAll('.card-drag-handle');
        
        if (reorderMode) {
            container.classList.add('reorder-mode-active');
            btnText.textContent = 'Done';
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-primary');
            handles.forEach(h => h.style.display = 'inline-block');
        } else {
            container.classList.remove('reorder-mode-active');
            btnText.textContent = 'Reorder';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-outline-primary');
            handles.forEach(h => h.style.display = 'none');
        }
    };
    
    // Toggle empty cards visibility
    window['toggleEmptyRelationships' + sectionUid] = function() {
        const emptyCards = document.querySelectorAll('#relationshipsSection' + sectionUid + ' .empty-relationship-card');
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + sectionUid);
        const toggleText = toggleBtn.querySelector('.toggle-text');
        const toggleIcon = toggleBtn.querySelector('i');
        
        let isHidden = emptyCards[0] && emptyCards[0].style.display === 'none';
        
        emptyCards.forEach(card => {
            if (isHidden) {
                card.style.display = 'block';
                card.style.opacity = '1';
                card.style.maxHeight = '1000px';
                card.style.marginBottom = '1rem';
            } else {
                card.style.opacity = '0';
                card.style.maxHeight = '0';
                card.style.marginBottom = '0';
                setTimeout(() => {
                    card.style.display = 'none';
                }, 300);
            }
        });
        
        if (isHidden) {
            toggleText.textContent = 'Hide Empty';
            toggleIcon.className = 'fas fa-eye-slash me-1';
        } else {
            toggleText.textContent = 'Show Empty';
            toggleIcon.className = 'fas fa-eye me-1';
        }
    };
    
    function showNotification(message, type = 'info') {
        const alertClass = type === 'success' ? 'alert-success' : 
                          type === 'danger' ? 'alert-danger' : 
                          type === 'warning' ? 'alert-warning' : 'alert-info';
        const icon = type === 'success' ? 'check-circle' : 
                    type === 'danger' ? 'exclamation-circle' : 
                    type === 'warning' ? 'exclamation-triangle' : 'info-circle';
        
        const notification = document.createElement('div');
        notification.className = `alert ${alertClass} alert-dismissible fade show position-fixed top-0 start-50 translate-middle-x mt-3`;
        notification.style.zIndex = '9999';
        notification.innerHTML = `
            <i class="fas fa-${icon} me-2"></i>
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    // Placeholder functions for add/delete (to be implemented)
    window['openAddRelationshipModal' + sectionUid] = function(definitionId, label) {
        alert('Add relationship feature to be implemented. Definition ID: ' + definitionId);
    };
    
    window['deleteRelationship' + sectionUid] = function(relationshipId) {
        if (confirm('Are you sure you want to delete this relationship?')) {
            alert('Delete relationship feature to be implemented. Relationship ID: ' + relationshipId);
        }
    };
    
    // ========== Hierarchy View Functionality ==========
    let hierarchyLoaded = false;
    
    async function loadHierarchy() {
        console.log(`[Section ${sectionUid}] loadHierarchy called, hierarchyLoaded=${hierarchyLoaded}`);
        if (hierarchyLoaded) return;
        
        const loadingDiv = document.getElementById('hierarchyLoading' + sectionUid);
        const contentDiv = document.getElementById('hierarchyContent' + sectionUid);
        
        console.log(`[Section ${sectionUid}] loadingDiv:`, loadingDiv);
        console.log(`[Section ${sectionUid}] contentDiv:`, contentDiv);
        
        if (!loadingDiv || !contentDiv) {
            console.error(`[Section ${sectionUid}] Missing hierarchy DOM elements!`);
            return;
        }
        
        loadingDiv.style.display = 'flex';
        contentDiv.innerHTML = '';
        
        try {
            console.log(`[Section ${sectionUid}] Fetching hierarchy from /api/entries/${entryId}/relationships/hierarchy`);
            const response = await fetch(`/api/entries/${entryId}/relationships/hierarchy`);
            const data = await response.json();
            
            if (!response.ok) {
                throw new Error(data.error || 'Failed to load hierarchy');
            }
            
            const hierarchy = data.hierarchy || [];
            renderHierarchyTree(hierarchy, contentDiv);
            hierarchyLoaded = true;
            
        } catch (error) {
            console.error('Error loading hierarchy:', error);
            contentDiv.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading hierarchy: ${escapeHtml(error.message)}
                    <button class="btn btn-sm btn-outline-danger ms-3" onclick="retryLoadHierarchy${sectionUid}()">
                        <i class="fas fa-redo me-1"></i>Retry
                    </button>
                </div>
            `;
        } finally {
            loadingDiv.style.display = 'none';
        }
    }
    
    function renderHierarchyTree(hierarchy, container) {
        console.log('renderHierarchyTree called with:', hierarchy);
        
        if (!hierarchy || hierarchy.length === 0) {
            container.innerHTML = `
                <div class="hierarchy-empty-state">
                    <i class="fas fa-sitemap"></i>
                    <p class="text-muted">No hierarchical relationships found</p>
                    <small class="text-muted d-block mb-2">Parent-child relationships will appear here</small>
                    <a href="/manage_relationships" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-cog me-1"></i>Configure Relationship Definitions
                    </a>
                </div>
            `;
            return;
        }
        
        // Build HTML for each relationship type tree
        let treeHtml = '';
        if (hierarchy.length > 1) {
            // Multiple relationship types - show separate trees with headers
            treeHtml = hierarchy.map((rootNode, index) => {
                const relationshipTypeName = rootNode.relationship_type_name || `Relationship ${index + 1}`;
                const treeContent = renderTreeNode(rootNode, 0);
                return `
                    <div class="relationship-tree-section mb-4">
                        <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                            <h6 class="text-primary mb-0">
                                <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                            </h6>
                        </div>
                        <div class="relationship-tree">${treeContent}</div>
                    </div>
                `;
            }).join('<hr class="my-3">');
        } else {
            // Single relationship type tree
            const rootNode = hierarchy[0];
            const relationshipTypeName = rootNode.relationship_type_name;
            const headerHtml = relationshipTypeName ? `
                <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                    <h6 class="text-primary mb-0">
                        <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                    </h6>
                </div>
            ` : '';
            treeHtml = `${headerHtml}<div class="relationship-tree">${renderTreeNode(rootNode, 0)}</div>`;
        }
        
        container.innerHTML = treeHtml;
        
        // Initialize tree toggles after rendering
        initializeTreeToggles();
    }
    
    function renderTreeNode(node, level) {
        const isTarget = node.is_target || false;  // The entry we're viewing
        const hasChildren = node.children && node.children.length > 0;
        
        const nodeClasses = ['tree-node-content'];
        if (isTarget) nodeClasses.push('current-entry');
        
        let html = `
            <div class="tree-node level-${level}" data-entry-id="${node.id}" style="padding-left: ${level * 20}px;">
                <div class="${nodeClasses.join(' ')}">
        `;
        
        // Toggle button or spacer
        if (hasChildren) {
            html += `
                <button class="tree-toggle-btn" data-node-id="${node.id}">
                    <i class="fas fa-chevron-down"></i>
                </button>
            `;
        } else {
            html += `<span class="tree-spacer"></span>`;
        }
        
        // Entry type icon
        html += `
            <span class="tree-entry-type" 
                  style="color: ${node.entry_type.color || '#6c757d'};"
                  title="${escapeHtml(node.entry_type.label)}">
                <i class="${node.entry_type.icon || 'fas fa-link'}"></i>
            </span>
        `;
        
        // Direction indicator (parent/child arrow)
        const direction = node.direction || 'unknown';
        if (direction === 'ancestor') {
            html += `
                <span class="tree-direction-icon" title="Parent/Ancestor">
                    <i class="fas fa-arrow-up text-primary"></i>
                </span>
            `;
        } else if (direction === 'descendant') {
            html += `
                <span class="tree-direction-icon" title="Child/Descendant">
                    <i class="fas fa-arrow-down text-success"></i>
                </span>
            `;
        }
        
        // Entry title and link
        html += `
            <a href="/entry/${node.id}" 
               class="tree-entry-link ${isTarget ? 'fw-bold' : ''}"
               target="_blank">
                ${escapeHtml(node.title)}
        `;
        
        // Badge for current/target entry
        if (isTarget) {
            html += `<span class="badge bg-success ms-2">Current</span>`;
        }
        html += `</a>`;
        
        // Status badge with dynamic color
        if (node.status) {
            const statusColor = node.status_color || '#6c757d';
            const textColor = getContrastColor(statusColor);
            html += `
                <span class="badge ms-2" style="background-color: ${statusColor}; color: ${textColor};">
                    ${escapeHtml(node.status)}
                </span>
            `;
        }
        
        // Relationship type label
        if (node.relationship_type) {
            html += `
                <small class="text-muted ms-2">
                    <i class="fas fa-link"></i> ${escapeHtml(node.relationship_type)}
                </small>
            `;
        }
        
        html += `</div>`; // Close tree-node-content
        
        // Children (recursive)
        if (hasChildren) {
            html += `<div class="tree-children" data-parent-id="${node.id}">`;
            for (const child of node.children) {
                html += renderTreeNode(child, level + 1);
            }
            html += `</div>`;
        }
        
        html += `</div>`; // Close tree-node
        
        return html;
    }
    
    function initializeTreeToggles() {
        const toggleButtons = document.querySelectorAll('.tree-toggle-btn');
        
        toggleButtons.forEach(button => {
            // Remove existing listeners by cloning
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            newButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const nodeId = this.dataset.nodeId;
                const childrenDiv = document.querySelector(`.tree-children[data-parent-id="${nodeId}"]`);
                const icon = this.querySelector('i');
                
                if (childrenDiv) {
                    childrenDiv.classList.toggle('collapsed');
                    
                    if (childrenDiv.classList.contains('collapsed')) {
                        icon.style.transform = 'rotate(-90deg)';
                    } else {
                        icon.style.transform = 'rotate(0deg)';
                    }
                }
            });
        });
    }
    
    // Retry function for hierarchy loading
    window['retryLoadHierarchy' + sectionUid] = function() {
        hierarchyLoaded = false;
        loadHierarchy();
    };
    
    // Setup tab event listeners
    function setupTabListeners() {
        const hierarchyTab = document.getElementById('hierarchyTab' + sectionUid + '-tab');
        
        console.log(`[Section ${sectionUid}] Setting up tab listeners, hierarchyTab:`, hierarchyTab);
        
        if (hierarchyTab) {
            hierarchyTab.addEventListener('shown.bs.tab', function() {
                console.log(`[Section ${sectionUid}] Hierarchy tab shown event triggered!`);
                loadHierarchy();
            });
            console.log(`[Section ${sectionUid}] Hierarchy tab listener added successfully`);
        } else {
            console.error(`[Section ${sectionUid}] Hierarchy tab button not found!`);
        }
    }
    
    // Initialize tab listeners
    console.log(`[Section ${sectionUid}] Initializing relationships section...`);
    setupTabListeners();
    
})();
</script>
