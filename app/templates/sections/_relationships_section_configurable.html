{# Relationships Section for Entry Detail V2 - With Section-Level Configuration #}
{# Expected context: section_id, section_config, entry #}
{% set section_uid = section_id|default('default') %}
{% set config = section_config|default({}) %}
{# Parse visible/hidden relationship types from config #}
{% set visible_rel_types = config.get('visible_relationship_types', [])|list %}
{% set hidden_rel_types = config.get('hidden_relationship_types', [])|list %}

<div class="relationships-section" id="relationshipsSection{{ section_uid }}">
  
  <!-- Section Header -->
  <div class="section-header mb-3 d-flex justify-content-between align-items-center">
    <h5 class="mb-0">
      <i class="fas fa-link me-2"></i>
      Related Records
    </h5>
    <div class="d-flex gap-2">
      <button id="toggleReorderMode{{ section_uid }}" 
              class="btn btn-sm btn-outline-primary" 
              onclick="toggleReorderMode{{ section_uid }}()"
              title="Reorder relationship type cards"
              style="display: none;">
        <i class="fas fa-grip-vertical me-1"></i>
        <span class="reorder-text">Reorder</span>
      </button>
      <button id="toggleEmptyRelationships{{ section_uid }}" 
              class="btn btn-sm btn-outline-secondary" 
              onclick="toggleEmptyRelationships{{ section_uid }}()"
              title="Show/hide relationship types with no records"
              style="display: none;">
        <i class="fas fa-eye me-1"></i>
        <span class="toggle-text">Show Empty</span>
      </button>
      <button id="toggleHiddenCards{{ section_uid }}" 
              class="btn btn-sm btn-outline-info" 
              onclick="toggleHiddenCards{{ section_uid }}()"
              title="Show/hide manually hidden relationship types"
              style="display: none;">
        <i class="fas fa-eye me-1"></i>
        <span class="toggle-text">Show Hidden</span>
      </button>
    </div>
  </div>

  <!-- Loading State -->
  <div id="relationshipsLoading{{ section_uid }}" class="text-center py-4">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-2 text-muted">Loading relationships...</p>
  </div>

  <!-- Section Content -->
  <div id="relatedRecordsContainer{{ section_uid }}" style="display: none;">
    
    <!-- Tabs Navigation -->
    <ul class="nav nav-tabs mb-3" id="relationshipsTabs{{ section_uid }}" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="groupedTab{{ section_uid }}-tab" data-bs-toggle="tab" 
                data-bs-target="#groupedTab{{ section_uid }}" type="button" role="tab" 
                aria-controls="groupedTab{{ section_uid }}" aria-selected="true">
          <i class="fas fa-th-list me-1"></i> Grouped View
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="hierarchyTab{{ section_uid }}-tab" data-bs-toggle="tab" 
                data-bs-target="#hierarchyTab{{ section_uid }}" type="button" role="tab" 
                aria-controls="hierarchyTab{{ section_uid }}" aria-selected="false">
          <i class="fas fa-sitemap me-1"></i> Hierarchy View
        </button>
      </li>
    </ul>
    
    <!-- Tab Content -->
    <div class="tab-content" id="relationshipsTabContent{{ section_uid }}">
      
      <!-- Grouped View Tab (default) -->
      <div class="tab-pane fade show active" id="groupedTab{{ section_uid }}" role="tabpanel" 
           aria-labelledby="groupedTab{{ section_uid }}-tab">
        <div id="groupedViewContainer{{ section_uid }}">
          <!-- Will be populated via JavaScript with cards for each relationship type -->
        </div>
      </div>
      
      <!-- Hierarchy View Tab -->
      <div class="tab-pane fade" id="hierarchyTab{{ section_uid }}" role="tabpanel" 
           aria-labelledby="hierarchyTab{{ section_uid }}-tab">
        
        <div id="hierarchyLoading{{ section_uid }}" class="text-center py-4" style="display: none;">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="mt-2 text-muted">Loading hierarchy...</p>
        </div>
        
        <div id="hierarchyContent{{ section_uid }}">
          <!-- Will be populated via JavaScript when tab is activated -->
        </div>
      </div>
      
    </div>
  </div>

</div>

<style>
/* Relationship cards styling with theme support */
.relationship-type-card {
    margin-bottom: 1rem;
    border: 1px solid var(--theme-border-color, var(--bs-border-color));
    border-radius: 0.5rem;
    overflow: visible;
    background-color: var(--theme-card-bg, var(--bs-body-bg));
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease, transform 0.2s ease, opacity 0.3s ease, max-height 0.3s ease;
}

/* Empty relationship cards - hidden by default */
.empty-relationship-card {
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    margin-bottom: 0;
    transition: opacity 0.3s ease, max-height 0.3s ease, margin-bottom 0.3s ease;
}

.empty-relationship-card .card-header {
    background-color: var(--bs-light);
    opacity: 0.85;
}

.relationship-type-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
}

.relationship-type-card .card-header {
    background-color: var(--bs-secondary-bg);
    border-bottom: 1px solid var(--bs-border-color);
    padding: 0.75rem 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    overflow: visible;
    gap: 0.5rem;
}

.card-drag-handle {
    cursor: grab;
    color: var(--bs-secondary);
}

.card-drag-handle:active {
    cursor: grabbing;
}

/* Drag and drop states */
.relationship-type-card.dragging {
    opacity: 0.5;
}

.relationship-type-card.drag-over {
    border-top: 3px solid var(--bs-primary);
}

.reorder-mode-active {
    padding: 0.5rem;
    border: 2px dashed var(--bs-border-color);
    border-radius: 0.5rem;
}

/* Hierarchy Tree Styles */
.relationship-tree {
    padding: 1rem 0;
}

.tree-node {
    margin-bottom: 0.25rem;
}

.tree-node-content {
    display: flex;
    align-items: center;
    padding: 0.5rem;
    border-radius: 0.25rem;
    transition: background-color 0.15s ease;
}

.tree-node-content:hover {
    background-color: var(--theme-hover-bg, var(--bs-secondary-bg));
}

.tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.1);
    border-left: 3px solid #0d6efd;
}

[data-bs-theme="dark"] .tree-node-content.current-entry {
    background-color: rgba(13, 110, 253, 0.2);
}

.tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.1);
    border-left: 3px solid #0dcaf0;
}

[data-bs-theme="dark"] .tree-node-content.parent-entry {
    background-color: rgba(13, 202, 240, 0.15);
}

.tree-toggle-btn {
    background: none;
    border: none;
    padding: 0.25rem;
    margin-right: 0.5rem;
    cursor: pointer;
    color: var(--bs-secondary);
    transition: transform 0.2s ease, color 0.2s ease;
    width: 20px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.tree-toggle-btn:hover {
    color: var(--bs-primary);
}

.tree-toggle-btn i {
    transition: transform 0.2s ease;
}

.tree-spacer {
    display: inline-block;
    width: 20px;
    margin-right: 0.5rem;
}

.tree-entry-type {
    margin-right: 0.5rem;
    font-size: 1rem;
}

.tree-direction-icon {
    margin-right: 0.5rem;
    font-size: 0.875rem;
    display: inline-flex;
    align-items: center;
}

.tree-direction-icon i {
    font-size: 0.75rem;
}

.tree-entry-link {
    color: var(--bs-body-color);
    text-decoration: none;
    margin-right: 0.5rem;
    transition: color 0.2s ease;
}

.tree-entry-link:hover {
    color: var(--bs-primary);
    text-decoration: underline;
}

.tree-children {
    overflow: hidden;
    max-height: 5000px;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    opacity: 1;
}

.tree-children.collapsed {
    max-height: 0;
    opacity: 0;
}

.status-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    background-color: var(--bs-secondary);
    color: white;
}

/* Empty state for hierarchy */
.hierarchy-empty-state {
    text-align: center;
    padding: 3rem 1rem;
    color: var(--bs-secondary-color);
}

.hierarchy-empty-state i {
    font-size: 3rem;
    opacity: 0.25;
    margin-bottom: 1rem;
    display: block;
}

/* Multi-select dropdown styling */
.relationship-state-filter[multiple] {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    background-size: 16px 12px;
    padding-right: 2.25rem;
    overflow-y: auto;
}

[data-bs-theme="dark"] .relationship-state-filter[multiple] {
    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23dee2e6' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3e%3c/svg%3e");
}

.relationship-state-filter[multiple]:focus {
    height: auto !important;
    max-height: 400px;
    min-height: 31px;
}

.relationship-type-card .card-header {
    position: relative;
    z-index: 10;
}
</style>

<script>
// Relationships Section with Configuration Support - Version 2025-11-08
(function() {
    const sectionUid = '{{ section_uid }}';
    const entryId = {{ entry.id }};
    const entryTypeId = {{ entry.entry_type_id }};
    const sectionId = {{ section_id|default('null') }};  // Section definition ID from section_order
    
    // Section-level configuration
    const sectionConfig = {
        visibleRelTypes: {{ visible_rel_types|tojson|safe }},
        hiddenRelTypes: {{ hidden_rel_types|tojson|safe }}
    };
    
    console.log('=== Relationships Section (Configurable) Loaded ===');
    console.log('Section UID:', sectionUid);
    console.log('Entry ID:', entryId);
    console.log('Config:', sectionConfig);
    
    let relationshipDefinitions = [];
    let customGridOrder = {};
    
    // Note binding state: Map of entry_id -> boolean (whether binding is enabled)
    let noteBingingState = new Map();
    
    // Utility function: Get contrasting text color for a background color
    function getContrastColor(hexColor) {
        if (!hexColor) return '#fff';
        const r = parseInt(hexColor.slice(1, 3), 16);
        const g = parseInt(hexColor.slice(3, 5), 16);
        const b = parseInt(hexColor.slice(5, 7), 16);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness > 128 ? '#000' : '#fff';
    }
    
    // Utility function: Escape HTML to prevent XSS
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Load relationships on page load
    loadRelationships();
    
    async function loadRelationships() {
        const loadingEl = document.getElementById('relationshipsLoading' + sectionUid);
        const containerEl = document.getElementById('relatedRecordsContainer' + sectionUid);
        
        try {
            // Fetch relationship definitions
            const defsResponse = await fetch('/api/relationship_definitions');
            const definitions = await defsResponse.json();
            
            // Filter to relevant definitions for this entry type
            let filteredDefs = definitions.filter(def => 
                def.entry_type_id_from === entryTypeId || 
                def.entry_type_id_to === entryTypeId
            );
            
            // Apply section-level filtering
            if (sectionConfig.visibleRelTypes.length > 0) {
                // If visible list is specified, only show those
                filteredDefs = filteredDefs.filter(def => 
                    sectionConfig.visibleRelTypes.includes(def.id)
                );
            } else if (sectionConfig.hiddenRelTypes.length > 0) {
                // If hidden list is specified, filter them out
                filteredDefs = filteredDefs.filter(def => 
                    !sectionConfig.hiddenRelTypes.includes(def.id)
                );
            }
            
            relationshipDefinitions = filteredDefs;
            
            // Fetch existing relationships
            const relsResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relsResponse.json();
            
            // Fetch custom grid order for this SECTION (not entry type)
            try {
                const orderResponse = await fetch(`/api/sections/{{ section_id }}/relationship_grid_order`);
                customGridOrder = await orderResponse.json();
            } catch (error) {
                console.warn('Could not load section grid order, using default:', error);
                customGridOrder = {};
            }
            
            // Group relationships by definition ID
            const groupedRelationships = {};
            relationships.forEach(rel => {
                if (!groupedRelationships[rel.definition_id]) {
                    groupedRelationships[rel.definition_id] = [];
                }
                groupedRelationships[rel.definition_id].push(rel);
            });
            
            // Sort definitions by custom order if available
            const sortedDefinitions = [...relationshipDefinitions].sort((a, b) => {
                const orderA = customGridOrder[a.id] !== undefined ? customGridOrder[a.id] : 999;
                const orderB = customGridOrder[b.id] !== undefined ? customGridOrder[b.id] : 999;
                return orderA - orderB;
            });
            
            // Render the cards
            await renderRelationshipCards(sortedDefinitions, groupedRelationships);
            
            loadingEl.style.display = 'none';
            containerEl.style.display = 'block';
            
        } catch (error) {
            console.error('Error loading relationships:', error);
            loadingEl.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading relationships: ${error.message}
                </div>
            `;
        }
    }
    
    async function renderRelationshipCards(definitions, groupedRelationships) {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        
        if (!container) {
            console.error('Grouped view container not found');
            return;
        }
        
        if (definitions.length === 0) {
            container.innerHTML = `
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>
                    No relationship types configured for this section.
                </div>
            `;
            return;
        }
        
        let html = '';
        let hasEmptyCards = false;
        
        definitions.forEach(def => {
            const isFromSide = def.entry_type_id_from === entryTypeId;
            const relationships = groupedRelationships[def.id] || [];
            
            const displayLabel = isFromSide ? def.label_from_side : def.label_to_side;
            const relevantCardinality = isFromSide ? def.cardinality_from : def.cardinality_to;
            const canAddMore = relevantCardinality === -1 || relationships.length < relevantCardinality;
            
            const isEmpty = relationships.length === 0;
            if (isEmpty) hasEmptyCards = true;
            
            html += `
                <div class="relationship-type-card card ${isEmpty ? 'empty-relationship-card' : ''}" 
                     data-definition-id="${def.id}"
                     style="${isEmpty ? 'display: none;' : ''}">
                    <div class="card-header">
                        <div class="d-flex align-items-center gap-2">
                            <i class="fas fa-grip-vertical card-drag-handle" 
                               style="display: none;"
                               title="Drag to reorder"></i>
                            <h6 class="mb-0">${escapeHtml(displayLabel || def.name)}</h6>
                            <span class="badge bg-secondary">${relationships.length}</span>
                        </div>
                        <div class="d-flex gap-2 align-items-center flex-wrap">
                            <select class="form-select form-select-sm relationship-state-filter" 
                                    data-definition-id="${def.id}"
                                    multiple
                                    style="width: auto; min-width: 180px; height: 31px;"
                                    title="Filter by status (Ctrl+Click for multiple)">
                                <option value="">All Status</option>
                                <option value="active">✓ Active (Ongoing)</option>
                                <option value="inactive">✕ Inactive (Completed)</option>
                                <optgroup label="Specific Status">
                                    <!-- Will be populated dynamically -->
                                </optgroup>
                            </select>
                            <button class="btn btn-sm btn-outline-secondary btn-save-filter" 
                                    data-definition-id="${def.id}"
                                    title="Save current filter as default for this relationship type">
                                <i class="fas fa-save"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-secondary btn-hide-card" 
                                    data-definition-id="${def.id}"
                                    title="Hide this relationship type in this section">
                                <i class="fas fa-eye-slash"></i>
                            </button>
                            <button class="btn btn-sm btn-primary btn-add-relationship" 
                                    data-definition-id="${def.id}"
                                    data-label="${escapeHtml(displayLabel || def.name)}"
                                    data-target-type-id="${isFromSide ? def.entry_type_id_to : def.entry_type_id_from}"
                                    data-target-type-label="${isFromSide ? def.entry_type_to_label : def.entry_type_from_label}"
                                    data-allow-quantity="${def.allow_quantity_unit}"
                                    ${!canAddMore ? 'disabled' : ''}
                                    title="${canAddMore ? 'Add ' + (displayLabel || def.name) : 'Maximum entries reached'}">
                                <i class="fas fa-plus me-1"></i>Add
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        ${relationships.length > 0 ? `
                            <table class="table table-sm table-hover mb-0">
                                <tbody>
                                    ${relationships.map(rel => renderRelationshipRow(rel, def)).join('')}
                                </tbody>
                            </table>
                        ` : `
                            <p class="text-muted mb-0">No ${escapeHtml(displayLabel || def.name).toLowerCase()} yet.</p>
                        `}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        
        // Show/hide toggle button if there are empty cards
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + sectionUid);
        if (toggleBtn && hasEmptyCards) {
            toggleBtn.style.display = 'block';
        }
        
        // Show reorder button if there are 2+ definitions
        const reorderBtn = document.getElementById('toggleReorderMode' + sectionUid);
        if (reorderBtn && definitions.length >= 2) {
            reorderBtn.style.display = 'block';
        }
        
        // Attach event listeners for filters
        attachEventListeners();
        
        // Load states for each relationship definition's filter dropdown
        definitions.forEach(def => {
            loadStatesForDefinition(def.id);
        });
        
        // Load and apply saved filter preferences
        loadFilterPreferences();
        
        // Apply hidden cards from database
        await applyHiddenCardsOnLoad();
        
        // Initialize drag and drop functionality
        initializeDragAndDrop();
    }
    
    function renderRelationshipRow(rel, def) {
        const statusCategory = rel.related_entry_status_category || 'active';
        const statusName = rel.related_entry_status || '';
        
        return `
            <tr class="relationship-item-row"
                data-status-category="${statusCategory}" 
                data-status="${statusName.toLowerCase()}">
                <td>
                    <a href="/entry/${rel.related_entry_id}" class="text-decoration-none">
                        <span class="badge" style="background-color: ${rel.related_entry_status_color};">
                            ${escapeHtml(rel.related_entry_status || 'N/A')}
                        </span>
                        ${escapeHtml(rel.related_entry_title)}
                    </a>
                    ${rel.quantity ? `<span class="text-muted ms-2">(${rel.quantity}${rel.unit ? ' ' + rel.unit : ''})</span>` : ''}
                </td>
                <td class="text-end">
                    <div class="btn-group" role="group">
                        <button type="button" class="btn btn-sm btn-outline-primary btn-bind-notes" 
                                data-entry-id="${rel.related_entry_id}" 
                                data-entry-title="${escapeHtml(rel.related_entry_title)}" 
                                title="Bind notes from this entry">
                            <i class="fas fa-link"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-danger btn-delete-relationship" 
                                data-relationship-id="${rel.relationship_id}"
                                data-entry-title="${escapeHtml(rel.related_entry_title)}"
                                title="Delete relationship">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }
    
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // ========== Filter Functionality ==========
    
    // Function to apply filters
    function applyFilters(definitionId) {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
        if (!card) return;
        
        const stateFilter = card.querySelector('.relationship-state-filter');
        const selectedValues = stateFilter ? Array.from(stateFilter.selectedOptions).map(opt => opt.value) : [];
        
        const rows = card.querySelectorAll('.relationship-item-row');
        rows.forEach(row => {
            const rowCategory = row.dataset.statusCategory || 'active';
            const rowState = (row.dataset.status || '').toLowerCase();
            
            // If "All Status" is selected or nothing selected, show all rows
            if (selectedValues.length === 0 || selectedValues.includes('')) {
                row.style.display = '';
                return;
            }
            
            // Check if row matches any of the selected filters
            let matches = false;
            
            // Check for category matches (active/inactive)
            if (selectedValues.includes('active') && rowCategory === 'active') {
                matches = true;
            }
            if (selectedValues.includes('inactive') && rowCategory === 'inactive') {
                matches = true;
            }
            
            // Check for specific state match
            if (selectedValues.includes(rowState)) {
                matches = true;
            }
            
            row.style.display = matches ? '' : 'none';
        });
    }
    
    // Function to load available states for a relationship definition
    async function loadStatesForDefinition(definitionId) {
        try {
            const def = relationshipDefinitions.find(d => d.id == definitionId);
            if (!def) return;
            
            const isFromSide = def.entry_type_id_from === entryTypeId;
            const targetTypeId = isFromSide ? def.entry_type_id_to : def.entry_type_id_from;
            
            // Fetch states for the target entry type
            const response = await fetch(`/api/entry_types/${targetTypeId}/states`);
            const states = await response.json();
            
            const container = document.getElementById('groupedViewContainer' + sectionUid);
            if (!container) return;
            
            const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (!card) return;
            
            const stateSelect = card.querySelector('.relationship-state-filter');
            if (!stateSelect) return;
            
            const optgroup = stateSelect.querySelector('optgroup');
            if (!optgroup) return;
            
            optgroup.innerHTML = '';
            
            // Group states by category
            const activeStates = states.filter(s => s.category === 'active');
            const inactiveStates = states.filter(s => s.category === 'inactive');
            
            // Add active states
            if (activeStates.length > 0) {
                activeStates.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                    const option = document.createElement('option');
                    option.value = state.name.toLowerCase();
                    option.textContent = `✓ ${state.name}`;
                    option.dataset.category = 'active';
                    optgroup.appendChild(option);
                });
            }
            
            // Add inactive states
            if (inactiveStates.length > 0) {
                inactiveStates.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                    const option = document.createElement('option');
                    option.value = state.name.toLowerCase();
                    option.textContent = `✕ ${state.name}`;
                    option.dataset.category = 'inactive';
                    optgroup.appendChild(option);
                });
            }
            
        } catch (error) {
            console.error('Error loading states for definition:', error);
        }
    }
    
    // Function to save filter preference
    async function saveFilterPreference(definitionId) {
        try {
            if (!sectionId) {
                console.error('Section ID is required for saving preferences');
                return;
            }
            
            const container = document.getElementById('groupedViewContainer' + sectionUid);
            if (!container) return;
            
            const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (!card) return;
            
            const stateFilter = card.querySelector('.relationship-state-filter');
            const selectedValues = stateFilter ? 
                Array.from(stateFilter.selectedOptions)
                    .map(opt => opt.value)
                    .filter(val => val !== '')
                    .join(',') : '';
            
            const preference = {
                entry_type_id: entryTypeId,
                section_id: sectionId,
                relationship_definition_id: parseInt(definitionId),
                filter_status_category: '',
                filter_specific_states: selectedValues
            };
            
            const response = await fetch('/api/section_relationship_preferences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(preference)
            });
            
            if (response.ok) {
                showNotification('Filter preference saved for all entries of this type', 'success');
            } else {
                throw new Error('Failed to save preference');
            }
        } catch (error) {
            console.error('Error saving filter preference:', error);
            showNotification('Error saving preference: ' + error.message, 'danger');
        }
    }
    
    // Function to load saved filter preferences from section-level config
    async function loadFilterPreferences() {
        try {
            if (!sectionId) {
                console.warn('Section ID not available, skipping filter preferences load');
                return;
            }
            
            const response = await fetch(`/api/section_relationship_preferences?entry_type_id=${entryTypeId}&section_id=${sectionId}`);
            if (!response.ok) {
                console.warn('Failed to load filter preferences');
                return;
            }
            
            const preferences = await response.json();
            
            const container = document.getElementById('groupedViewContainer' + sectionUid);
            if (!container) return;
            
            preferences.forEach(pref => {
                const card = container.querySelector(`.relationship-type-card[data-definition-id="${pref.relationship_definition_id}"]`);
                if (!card) return;
                
                const stateFilter = card.querySelector('.relationship-state-filter');
                
                if (stateFilter && pref.filter_specific_states) {
                    const values = pref.filter_specific_states.split(',').filter(v => v.trim());
                    if (values.length > 0) {
                        // Deselect all first
                        Array.from(stateFilter.options).forEach(option => {
                            option.selected = false;
                        });
                        // Select matching values
                        Array.from(stateFilter.options).forEach(option => {
                            if (values.includes(option.value)) {
                                option.selected = true;
                            }
                        });
                    }
                }
                
                // Apply the filter
                applyFilters(pref.relationship_definition_id);
            });
        } catch (error) {
            console.error('Error loading filter preferences:', error);
        }
    }
    
    function attachEventListeners() {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        // State filter dropdowns
        container.querySelectorAll('.relationship-state-filter').forEach(filter => {
            filter.addEventListener('change', function() {
                applyFilters(this.dataset.definitionId);
            });
        });
        
        // Save filter buttons
        container.querySelectorAll('.btn-save-filter').forEach(btn => {
            btn.addEventListener('click', async function() {
                const definitionId = this.dataset.definitionId;
                await saveFilterPreference(definitionId);
            });
        });
        
        // Hide card buttons
        container.querySelectorAll('.btn-hide-card').forEach(btn => {
            btn.addEventListener('click', async function() {
                const definitionId = this.dataset.definitionId;
                await hideCard(definitionId);
            });
        });
        
        // Add relationship buttons
        container.querySelectorAll('.btn-add-relationship').forEach(btn => {
            btn.addEventListener('click', function() {
                const definitionId = this.dataset.definitionId;
                const label = this.dataset.label;
                const targetTypeId = this.dataset.targetTypeId;
                const targetTypeLabel = this.dataset.targetTypeLabel;
                const allowQuantity = this.dataset.allowQuantity === 'true';
                
                openAddRelationshipModal(definitionId, label, targetTypeId, targetTypeLabel, allowQuantity);
            });
        });
        
        // Delete relationship buttons
        container.querySelectorAll('.btn-delete-relationship').forEach(btn => {
            btn.addEventListener('click', function() {
                const relationshipId = this.dataset.relationshipId;
                deleteRelationship(relationshipId);
            });
        });
        
        // Bind notes buttons
        container.querySelectorAll('.btn-bind-notes').forEach(btn => {
            btn.addEventListener('click', function() {
                const targetEntryId = this.dataset.entryId;
                const targetEntryTitle = this.dataset.entryTitle;
                showBindNotesModal(targetEntryId, targetEntryTitle);
            });
        });
    }
    
    // ========== Hide/Show Card Functionality (SQL-backed) ==========
    
    // Function to hide a relationship card
    async function hideCard(definitionId) {
        try {
            if (!sectionId) {
                console.error('Section ID is required for hiding cards');
                return;
            }
            
            // Save hidden state to database
            const preference = {
                entry_type_id: entryTypeId,
                section_id: sectionId,
                relationship_definition_id: parseInt(definitionId),
                is_hidden: true
            };
            
            const response = await fetch('/api/section_relationship_preferences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(preference)
            });
            
            if (!response.ok) {
                throw new Error('Failed to save hidden state');
            }
            
            // Hide the card in UI
            const container = document.getElementById('groupedViewContainer' + sectionUid);
            if (!container) return;
            
            const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (card) {
                card.classList.add('manually-hidden-card');
                card.style.display = 'none';
            }
            
            // Show the "Show Hidden" button
            updateHiddenCardsToggle();
            
            showNotification('Relationship type hidden for all entries of this type', 'info');
        } catch (error) {
            console.error('Error hiding card:', error);
            showNotification('Error hiding card: ' + error.message, 'danger');
        }
    }
    
    // Function to toggle visibility of hidden cards
    window['toggleHiddenCards' + sectionUid] = function() {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const hiddenCards = container.querySelectorAll('.manually-hidden-card');
        const toggleBtn = document.getElementById('toggleHiddenCards' + sectionUid);
        const toggleText = toggleBtn.querySelector('.toggle-text');
        const toggleIcon = toggleBtn.querySelector('i');
        
        // Check current state
        const isHidden = Array.from(hiddenCards).some(card => card.style.display === 'none');
        
        hiddenCards.forEach(card => {
            if (isHidden) {
                // Show the card
                card.style.display = 'block';
                // Add an "unhide" button to the card
                addUnhideButton(card);
            } else {
                // Hide the card again
                card.style.display = 'none';
                // Remove the unhide button
                removeUnhideButton(card);
            }
        });
        
        // Update button text
        if (isHidden) {
            toggleText.textContent = 'Hide Hidden';
            toggleIcon.classList.remove('fa-eye');
            toggleIcon.classList.add('fa-eye-slash');
        } else {
            toggleText.textContent = 'Show Hidden';
            toggleIcon.classList.remove('fa-eye-slash');
            toggleIcon.classList.add('fa-eye');
        }
    };
    
    function addUnhideButton(card) {
        const definitionId = card.dataset.definitionId;
        const header = card.querySelector('.card-header');
        if (!header) return;
        
        // Check if button already exists
        if (header.querySelector('.btn-unhide-card')) return;
        
        const buttonGroup = header.querySelector('.d-flex.gap-2');
        if (!buttonGroup) return;
        
        const unhideBtn = document.createElement('button');
        unhideBtn.className = 'btn btn-sm btn-success btn-unhide-card';
        unhideBtn.dataset.definitionId = definitionId;
        unhideBtn.title = 'Unhide this relationship type';
        unhideBtn.innerHTML = '<i class="fas fa-eye"></i> Unhide';
        unhideBtn.addEventListener('click', async function() {
            await unhideCard(definitionId);
        });
        
        // Insert at the beginning of the button group
        buttonGroup.insertBefore(unhideBtn, buttonGroup.firstChild);
    }
    
    function removeUnhideButton(card) {
        const unhideBtn = card.querySelector('.btn-unhide-card');
        if (unhideBtn) {
            unhideBtn.remove();
        }
    }
    
    async function unhideCard(definitionId) {
        try {
            if (!sectionId) {
                console.error('Section ID is required for unhiding cards');
                return;
            }
            
            // Update hidden state in database
            const preference = {
                entry_type_id: entryTypeId,
                section_id: sectionId,
                relationship_definition_id: parseInt(definitionId),
                is_hidden: false
            };
            
            const response = await fetch('/api/section_relationship_preferences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(preference)
            });
            
            if (!response.ok) {
                throw new Error('Failed to save unhidden state');
            }
            
            // Remove the manually-hidden class and show the card in UI
            const container = document.getElementById('groupedViewContainer' + sectionUid);
            if (!container) return;
            
            const card = container.querySelector(`.relationship-type-card[data-definition-id="${definitionId}"]`);
            if (card) {
                card.classList.remove('manually-hidden-card');
                card.style.display = 'block';
                removeUnhideButton(card);
            }
            
            // Update the "Show Hidden" button visibility
            updateHiddenCardsToggle();
            
            showNotification('Relationship type unhidden for all entries of this type', 'success');
        } catch (error) {
            console.error('Error unhiding card:', error);
            showNotification('Error unhiding card: ' + error.message, 'danger');
        }
    }
    
    function updateHiddenCardsToggle() {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const hiddenCards = container.querySelectorAll('.manually-hidden-card');
        
        const toggleBtn = document.getElementById('toggleHiddenCards' + sectionUid);
        if (toggleBtn) {
            toggleBtn.style.display = hiddenCards.length > 0 ? 'inline-block' : 'none';
        }
    }
    
    async function applyHiddenCardsOnLoad() {
        // Load hidden cards from database
        try {
            if (!sectionId) {
                console.warn('Section ID not available, skipping hidden cards load');
                return;
            }
            
            const response = await fetch(`/api/section_relationship_preferences?entry_type_id=${entryTypeId}&section_id=${sectionId}`);
            if (!response.ok) {
                console.warn('Failed to load hidden card preferences');
                return;
            }
            
            const preferences = await response.json();
            
            const container = document.getElementById('groupedViewContainer' + sectionUid);
            if (!container) return;
            
            // Apply hidden state to each card
            preferences.forEach(pref => {
                if (pref.is_hidden) {
                    const card = container.querySelector(`.relationship-type-card[data-definition-id="${pref.relationship_definition_id}"]`);
                    if (card) {
                        card.classList.add('manually-hidden-card');
                        card.style.display = 'none';
                    }
                }
            });
            
            updateHiddenCardsToggle();
        } catch (error) {
            console.error('Error loading hidden cards:', error);
        }
    }
    
    // ========== Grid Reordering Functionality ==========
    let reorderMode = false;
    let draggedElement = null;
    
    function initializeDragAndDrop() {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const cards = container.querySelectorAll('.relationship-type-card');
        
        cards.forEach(card => {
            const handle = card.querySelector('.card-drag-handle');
            
            if (!handle) return;
            
            // Make the handle draggable
            handle.addEventListener('mousedown', function(e) {
                if (!reorderMode) return;
                card.setAttribute('draggable', 'true');
            });
            
            handle.addEventListener('mouseup', function(e) {
                card.setAttribute('draggable', 'false');
            });
            
            // Drag start
            card.addEventListener('dragstart', function(e) {
                if (!reorderMode) {
                    e.preventDefault();
                    return;
                }
                draggedElement = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            
            // Drag end
            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.setAttribute('draggable', 'false');
                
                // Remove all drag-over classes
                const allCards = container.querySelectorAll('.relationship-type-card');
                allCards.forEach(c => c.classList.remove('drag-over'));
                
                // Save the new order
                saveGridOrder();
            });
            
            // Drag over
            card.addEventListener('dragover', function(e) {
                if (!reorderMode || !draggedElement) return;
                
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const afterElement = getDragAfterElement(container, e.clientY);
                if (afterElement == null) {
                    container.appendChild(draggedElement);
                } else {
                    container.insertBefore(draggedElement, afterElement);
                }
            });
            
            // Drag enter
            card.addEventListener('dragenter', function(e) {
                if (!reorderMode || this === draggedElement) return;
                this.classList.add('drag-over');
            });
            
            // Drag leave
            card.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });
        });
    }
    
    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.relationship-type-card:not(.dragging):not(.empty-relationship-card)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    async function saveGridOrder() {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const cards = container.querySelectorAll('.relationship-type-card:not(.empty-relationship-card)');
        const orderList = [];
        
        cards.forEach((card, index) => {
            const definitionId = parseInt(card.dataset.definitionId);
            orderList.push({
                definition_id: definitionId,
                order: index
            });
        });
        
        try {
            const response = await fetch(`/api/sections/{{ section_id }}/relationship_grid_order`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ order: orderList })
            });
            
            if (response.ok) {
                console.log('Grid order saved successfully for section {{ section_id }}');
                showNotification('Grid order saved for this section', 'success');
                // Update the custom order cache
                orderList.forEach(item => {
                    customGridOrder[item.definition_id] = item.order;
                });
            } else {
                console.error('Failed to save grid order');
                showNotification('Failed to save grid order', 'danger');
            }
        } catch (error) {
            console.error('Error saving grid order:', error);
            showNotification('Error saving grid order', 'danger');
        }
    }
    
    // Toggle reorder mode
    window['toggleReorderMode' + sectionUid] = function() {
        reorderMode = !reorderMode;
        
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        const btn = document.getElementById('toggleReorderMode' + sectionUid);
        const btnText = btn.querySelector('.reorder-text');
        const handles = container.querySelectorAll('.card-drag-handle');
        
        if (reorderMode) {
            container.classList.add('reorder-mode-active');
            btnText.textContent = 'Done';
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-primary');
            handles.forEach(h => h.style.display = 'inline-block');
        } else {
            container.classList.remove('reorder-mode-active');
            btnText.textContent = 'Reorder';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-outline-primary');
            handles.forEach(h => h.style.display = 'none');
        }
    };
    
    // Toggle empty cards visibility
    window['toggleEmptyRelationships' + sectionUid] = function() {
        const emptyCards = document.querySelectorAll('#relationshipsSection' + sectionUid + ' .empty-relationship-card');
        const toggleBtn = document.getElementById('toggleEmptyRelationships' + sectionUid);
        const toggleText = toggleBtn.querySelector('.toggle-text');
        const toggleIcon = toggleBtn.querySelector('i');
        
        let isHidden = emptyCards[0] && emptyCards[0].style.display === 'none';
        
        emptyCards.forEach(card => {
            if (isHidden) {
                card.style.display = 'block';
                card.style.opacity = '1';
                card.style.maxHeight = '1000px';
                card.style.marginBottom = '1rem';
            } else {
                card.style.opacity = '0';
                card.style.maxHeight = '0';
                card.style.marginBottom = '0';
                setTimeout(() => {
                    card.style.display = 'none';
                }, 300);
            }
        });
        
        if (isHidden) {
            toggleText.textContent = 'Hide Empty';
            toggleIcon.className = 'fas fa-eye-slash me-1';
        } else {
            toggleText.textContent = 'Show Empty';
            toggleIcon.className = 'fas fa-eye me-1';
        }
    };
    
    function showNotification(message, type = 'info') {
        const alertClass = type === 'success' ? 'alert-success' : 
                          type === 'danger' ? 'alert-danger' : 
                          type === 'warning' ? 'alert-warning' : 'alert-info';
        const icon = type === 'success' ? 'check-circle' : 
                    type === 'danger' ? 'exclamation-circle' : 
                    type === 'warning' ? 'exclamation-triangle' : 'info-circle';
        
        const notification = document.createElement('div');
        notification.className = `alert ${alertClass} alert-dismissible fade show position-fixed top-0 start-50 translate-middle-x mt-3`;
        notification.style.zIndex = '9999';
        notification.innerHTML = `
            <i class="fas fa-${icon} me-2"></i>
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 3000);
    }
    
    // Functions for add/delete (to be implemented)
    // Copy the complete implementation from v2 template
    async function openAddRelationshipModal(definitionId, label, targetTypeId, targetTypeLabel, allowQuantity) {
        // Create and show modal
        const modalId = 'addRelModal_' + definitionId;
        
        // Remove existing modal if any
        const existingModal = document.getElementById(modalId);
        if (existingModal) {
            existingModal.remove();
        }
        
        // Check if this definition has any current relationships
        let hasCurrentRelationships = false;
        try {
            const relResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relResponse.json();
            hasCurrentRelationships = relationships.some(rel => rel.definition_id == definitionId);
        } catch (error) {
            console.error('Error checking current relationships:', error);
        }
        
        // Only check for shared relationship opportunities if there are NO current relationships for this definition
        let importOpportunitiesHtml = '';
        if (!hasCurrentRelationships) {
            try {
                const response = await fetch(`/api/entries/${entryId}/shared_relationship_opportunities`);
                if (response.ok) {
                    const allOpportunities = await response.json();
                    
                    // Filter opportunities to only those matching this definition
                    const relevantOpportunities = allOpportunities.filter(opp => 
                        opp.relationship_definition && opp.relationship_definition.id == definitionId
                    );
                    
                    if (relevantOpportunities.length > 0) {
                        const totalTargets = relevantOpportunities.reduce((sum, opp) => 
                            sum + opp.potential_targets.length, 0);
                        
                        importOpportunitiesHtml = `
                            <div class="alert alert-info mb-3">
                                <i class="fas fa-lightbulb me-2"></i>
                                <strong>Quick Import Available:</strong> 
                                Found ${totalTargets} ${escapeHtml(targetTypeLabel.toLowerCase())}${totalTargets !== 1 ? 's' : ''} 
                                from ${relevantOpportunities.length} related ${relevantOpportunities.length === 1 ? 'entry' : 'entries'}.
                                <button type="button" 
                                        class="btn btn-sm btn-success ms-2" 
                                        id="btnShowImport_${definitionId}">
                                    <i class="fas fa-download me-1"></i>
                                    Import from Existing
                                </button>
                            </div>
                            <div id="importSection_${definitionId}" style="display: none;" class="mb-3">
                                ${relevantOpportunities.map((opp, oppIndex) => {
                                    const intermediateEntry = opp.intermediate_entry;
                                    const targets = opp.potential_targets;
                                    const relDef = opp.relationship_definition;
                                    
                                    return `
                                        <div class="card mb-2">
                                            <div class="card-header py-2 d-flex justify-content-between align-items-center">
                                                <div>
                                                    <strong>From: ${escapeHtml(intermediateEntry.title)}</strong>
                                                    <span class="badge bg-secondary ms-2">${targets.length} available</span>
                                                </div>
                                                <div>
                                                    <button type="button" class="btn btn-sm btn-success" 
                                                            onclick="selectAllInGroup${definitionId}(${oppIndex})">
                                                        <i class="fas fa-check-double"></i> All
                                                    </button>
                                                    <button type="button" class="btn btn-sm btn-outline-secondary ms-1" 
                                                            onclick="deselectAllInGroup${definitionId}(${oppIndex})">
                                                        <i class="fas fa-times"></i> None
                                                    </button>
                                                </div>
                                            </div>
                                            <div class="card-body p-2" id="targetGroup_${definitionId}_${oppIndex}">
                                                ${targets.map((target, targetIndex) => {
                                                    const targetEntry = target.target_entry;
                                                    const sourceRel = target.source_relationship;
                                                    const uniqueId = definitionId + '_' + oppIndex + '_' + targetIndex;
                                                    
                                                    return `
                                                        <div class="form-check border rounded p-2 mb-2 import-target-item" 
                                                             data-group="${oppIndex}">
                                                            <input class="form-check-input import-entry-checkbox" 
                                                                   type="checkbox" 
                                                                   checked
                                                                   value="${targetEntry.id}"
                                                                   id="import_${uniqueId}"
                                                                   data-definition-id="${relDef.id}"
                                                                   data-quantity="${sourceRel.quantity || ''}"
                                                                   data-unit="${sourceRel.unit || ''}">
                                                            <label class="form-check-label d-flex justify-content-between align-items-start w-100" 
                                                                   for="import_${uniqueId}">
                                                                <div class="flex-grow-1">
                                                                    <strong>${escapeHtml(targetEntry.title)}</strong>
                                                                    ${targetEntry.status ? `
                                                                        <span class="badge ms-2" 
                                                                              style="background-color: ${targetEntry.status_color || '#6c757d'}; font-size: 0.7rem;">
                                                                            ${escapeHtml(targetEntry.status)}
                                                                        </span>
                                                                    ` : ''}
                                                                </div>
                                                                ${relDef.allow_quantity_unit && (sourceRel.quantity || sourceRel.unit) ? `
                                                                    <div class="text-end ms-2">
                                                                        <small class="text-muted d-block">
                                                                            ${sourceRel.quantity || ''} ${sourceRel.unit || ''}
                                                                        </small>
                                                                    </div>
                                                                ` : ''}
                                                            </label>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                                <div class="d-flex gap-2 mt-3">
                                    <button type="button" 
                                            class="btn btn-sm btn-outline-secondary" 
                                            id="btnSelectAllImport_${definitionId}">
                                        Select All
                                    </button>
                                    <button type="button" 
                                            class="btn btn-sm btn-outline-secondary" 
                                            id="btnDeselectAllImport_${definitionId}">
                                        Deselect All
                                    </button>
                                    <button type="button" 
                                            class="btn btn-sm btn-success ms-auto" 
                                            id="btnExecuteImport_${definitionId}">
                                        <i class="fas fa-check me-1"></i>
                                        Import Selected
                                    </button>
                                </div>
                            </div>
                            
                            <hr class="my-3">
                        `;
                        
                        // Create group selection functions dynamically
                        window[`selectAllInGroup${definitionId}`] = function(groupIndex) {
                            document.querySelectorAll(`#targetGroup_${definitionId}_${groupIndex} .import-entry-checkbox`)
                                .forEach(cb => cb.checked = true);
                        };
                        window[`deselectAllInGroup${definitionId}`] = function(groupIndex) {
                            document.querySelectorAll(`#targetGroup_${definitionId}_${groupIndex} .import-entry-checkbox`)
                                .forEach(cb => cb.checked = false);
                        };
                    }
                }
            } catch (error) {
                console.error('Error checking shared relationship opportunities:', error);
            }
        }
        
        const modalHtml = `
            <div class="modal fade" id="${modalId}" tabindex="-1">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-plus me-2"></i>
                                Add ${escapeHtml(label)}
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            ${importOpportunitiesHtml}
                            
                            <!-- Search existing entries -->
                            <div class="mb-3">
                                <label class="form-label">Search Existing ${escapeHtml(targetTypeLabel)}</label>
                                <input type="text" 
                                       class="form-control" 
                                       id="searchEntry_${definitionId}"
                                       placeholder="Start typing to search...">
                                <div id="searchResults_${definitionId}" 
                                     class="list-group mt-2" 
                                     style="max-height: 200px; overflow-y: auto; display: none;">
                                </div>
                            </div>
                            
                            <div class="text-center my-3">
                                <span class="text-muted">— OR —</span>
                            </div>
                            
                            <!-- Create new entry -->
                            <div class="form-check mb-3">
                                <input class="form-check-input" 
                                       type="checkbox" 
                                       id="createNew_${definitionId}">
                                <label class="form-check-label" for="createNew_${definitionId}">
                                    Create a new ${escapeHtml(targetTypeLabel)} instead
                                </label>
                            </div>
                            
                            <div id="newEntryFields_${definitionId}" style="display: none;">
                                <div class="mb-3">
                                    <label class="form-label">Title *</label>
                                    <input type="text" 
                                           class="form-control" 
                                           id="newEntryTitle_${definitionId}"
                                           placeholder="Enter title">
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Description</label>
                                    <textarea class="form-control" 
                                              id="newEntryDescription_${definitionId}"
                                              rows="3"
                                              placeholder="Optional description"></textarea>
                                </div>
                            </div>
                            
                            ${allowQuantity ? `
                                <hr class="my-3">
                                <div class="row">
                                    <div class="col-6">
                                        <label class="form-label">Quantity</label>
                                        <input type="number" 
                                               step="any" 
                                               class="form-control" 
                                               id="quantity_${definitionId}"
                                               placeholder="e.g., 2.5">
                                    </div>
                                    <div class="col-6">
                                        <label class="form-label">Unit</label>
                                        <input type="text" 
                                               class="form-control" 
                                               id="unit_${definitionId}"
                                               placeholder="e.g., kg, cups">
                                    </div>
                                </div>
                            ` : ''}
                            
                            <input type="hidden" id="selectedEntryId_${definitionId}">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                Cancel
                            </button>
                            <button type="button" 
                                    class="btn btn-primary" 
                                    id="btnSubmit_${definitionId}">
                                <i class="fas fa-check me-1"></i>
                                Add Relationship
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = new bootstrap.Modal(document.getElementById(modalId));
        modal.show();
        
        // Setup modal interactions
        setupModalInteractions(modalId, definitionId, targetTypeId, allowQuantity);
        
        // Cleanup on hide
        document.getElementById(modalId).addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    }
    
    async function setupModalInteractions(modalId, definitionId, targetTypeId, allowQuantity) {
        const searchInput = document.getElementById(`searchEntry_${definitionId}`);
        const searchResults = document.getElementById(`searchResults_${definitionId}`);
        const createNewCheckbox = document.getElementById(`createNew_${definitionId}`);
        const newEntryFields = document.getElementById(`newEntryFields_${definitionId}`);
        const selectedEntryIdInput = document.getElementById(`selectedEntryId_${definitionId}`);
        const submitBtn = document.getElementById(`btnSubmit_${definitionId}`);
        
        // Get already related entry IDs for this definition to exclude them
        const alreadyRelatedIds = new Set();
        try {
            const relResponse = await fetch(`/api/entries/${entryId}/relationships`);
            const relationships = await relResponse.json();
            relationships.forEach(rel => {
                if (rel.definition_id == definitionId) {
                    alreadyRelatedIds.add(rel.related_entry_id);
                }
            });
            // Also exclude the current entry itself
            alreadyRelatedIds.add(parseInt(entryId));
            
            console.log('Excluded entry IDs for definition', definitionId, ':', Array.from(alreadyRelatedIds));
        } catch (error) {
            console.error('Error fetching existing relationships:', error);
        }
        
        let searchTimeout;
        
        // Search functionality
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            if (query.length < 2) {
                searchResults.style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(`/api/search_entries?q=${encodeURIComponent(query)}&entry_type_id=${targetTypeId}`);
                    const entries = await response.json();
                    
                    // Filter out already related entries
                    const availableEntries = entries.filter(entry => !alreadyRelatedIds.has(entry.id));
                    
                    if (availableEntries.length === 0) {
                        searchResults.innerHTML = '<div class="list-group-item text-muted">No available entries found</div>';
                    } else {
                        searchResults.innerHTML = availableEntries.map(entry => `
                            <button type="button" 
                                    class="list-group-item list-group-item-action search-result-item"
                                    data-entry-id="${entry.id}"
                                    data-entry-title="${escapeHtml(entry.title)}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <span>${escapeHtml(entry.title)}</span>
                                    <small class="badge bg-secondary">${escapeHtml(entry.status || 'Active')}</small>
                                </div>
                            </button>
                        `).join('');
                        
                        // Attach click handlers
                        document.querySelectorAll('.search-result-item').forEach(item => {
                            item.addEventListener('click', function() {
                                selectedEntryIdInput.value = this.dataset.entryId;
                                searchInput.value = this.dataset.entryTitle;
                                searchResults.style.display = 'none';
                                
                                // Uncheck create new
                                createNewCheckbox.checked = false;
                                newEntryFields.style.display = 'none';
                            });
                        });
                    }
                    
                    searchResults.style.display = 'block';
                } catch (error) {
                    console.error('Search error:', error);
                    searchResults.innerHTML = '<div class="list-group-item text-danger">Search failed</div>';
                    searchResults.style.display = 'block';
                }
            }, 300);
        });
        
        // Create new toggle
        createNewCheckbox.addEventListener('change', function() {
            if (this.checked) {
                newEntryFields.style.display = 'block';
                searchInput.disabled = true;
                selectedEntryIdInput.value = '';
                searchResults.style.display = 'none';
            } else {
                newEntryFields.style.display = 'none';
                searchInput.disabled = false;
            }
        });
        
        // Submit
        submitBtn.addEventListener('click', async function() {
            const isCreatingNew = createNewCheckbox.checked;
            const quantity = allowQuantity ? document.getElementById(`quantity_${definitionId}`).value : null;
            const unit = allowQuantity ? document.getElementById(`unit_${definitionId}`).value : null;
            
            if (isCreatingNew) {
                const title = document.getElementById(`newEntryTitle_${definitionId}`).value.trim();
                const description = document.getElementById(`newEntryDescription_${definitionId}`).value.trim();
                
                if (!title) {
                    alert('Please enter a title for the new entry');
                    return;
                }
                
                await createNewAndLink(definitionId, title, description, quantity, unit);
            } else {
                const targetEntryId = selectedEntryIdInput.value;
                
                if (!targetEntryId) {
                    alert('Please search and select an entry, or choose to create a new one');
                    return;
                }
                
                await linkExisting(definitionId, targetEntryId, quantity, unit);
            }
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById(modalId)).hide();
        });
        
        // Import functionality handlers
        const showImportBtn = document.getElementById(`btnShowImport_${definitionId}`);
        const importSection = document.getElementById(`importSection_${definitionId}`);
        const selectAllBtn = document.getElementById(`btnSelectAllImport_${definitionId}`);
        const deselectAllBtn = document.getElementById(`btnDeselectAllImport_${definitionId}`);
        const executeImportBtn = document.getElementById(`btnExecuteImport_${definitionId}`);
        
        if (showImportBtn && importSection) {
            showImportBtn.addEventListener('click', function() {
                if (importSection.style.display === 'none') {
                    importSection.style.display = 'block';
                    this.innerHTML = '<i class="fas fa-chevron-up me-1"></i>Hide Import Options';
                } else {
                    importSection.style.display = 'none';
                    this.innerHTML = '<i class="fas fa-download me-1"></i>Import from Existing';
                }
            });
        }
        
        if (selectAllBtn) {
            selectAllBtn.addEventListener('click', function() {
                document.querySelectorAll('.import-entry-checkbox').forEach(cb => cb.checked = true);
            });
        }
        
        if (deselectAllBtn) {
            deselectAllBtn.addEventListener('click', function() {
                document.querySelectorAll('.import-entry-checkbox').forEach(cb => cb.checked = false);
            });
        }
        
        if (executeImportBtn) {
            executeImportBtn.addEventListener('click', async function() {
                const selectedEntryIds = Array.from(document.querySelectorAll('.import-entry-checkbox:checked'))
                    .map(cb => parseInt(cb.value));
                
                if (selectedEntryIds.length === 0) {
                    alert('Please select at least one entry to import');
                    return;
                }
                
                await importMultipleEntries(definitionId, selectedEntryIds, allowQuantity);
                
                // Close modal
                bootstrap.Modal.getInstance(document.getElementById(modalId)).hide();
            });
        }
    }
    
    async function linkExisting(definitionId, targetEntryId, quantity, unit) {
        try {
            const payload = {
                definition_id: parseInt(definitionId),
                related_entry_id: parseInt(targetEntryId)
            };
            
            if (quantity) payload.quantity = parseFloat(quantity);
            if (unit) payload.unit = unit;
            
            const response = await fetch(`/api/entries/${entryId}/relationships`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create relationship');
            }
            
            // Reload relationships
            await loadRelationships();
            
            showNotification('Relationship created successfully', 'success');
        } catch (error) {
            console.error('Error creating relationship:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function createNewAndLink(definitionId, title, description, quantity, unit) {
        try {
            const payload = {
                definition_id: parseInt(definitionId),
                name: title,
                description: description
            };
            
            if (quantity) payload.quantity = parseFloat(quantity);
            if (unit) payload.unit = unit;
            
            const response = await fetch(`/api/entries/${entryId}/relationships/new`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to create entry and relationship');
            }
            
            // Reload relationships
            await loadRelationships();
            
            showNotification('New entry created and linked successfully', 'success');
        } catch (error) {
            console.error('Error creating entry:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    async function importMultipleEntries(definitionId, entryIds, allowQuantity) {
        try {
            // Collect all selected entries with their data from the checkboxes
            const relationships = [];
            const checkboxes = document.querySelectorAll('.import-entry-checkbox:checked');
            
            checkboxes.forEach(cb => {
                const relationshipData = {
                    definition_id: parseInt(cb.dataset.definitionId || definitionId),
                    target_entry_id: parseInt(cb.value)
                };
                
                // Include quantity/unit if they exist in the data attributes
                if (cb.dataset.quantity) {
                    relationshipData.quantity = parseFloat(cb.dataset.quantity);
                }
                if (cb.dataset.unit) {
                    relationshipData.unit = cb.dataset.unit;
                }
                
                relationships.push(relationshipData);
            });
            
            if (relationships.length === 0) {
                showNotification('No entries selected for import', 'warning');
                return;
            }
            
            // Show progress notification
            showNotification(`Importing ${relationships.length} relationships...`, 'info');
            
            // Use the shared relationships API endpoint
            const response = await fetch(`/api/entries/${entryId}/import_shared_relationships`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ relationships: relationships })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to import relationships');
            }
            
            const result = await response.json();
            
            // Reload relationships to show the imported ones
            await loadRelationships();
            
            showNotification(`Successfully imported ${result.created} relationship${result.created !== 1 ? 's' : ''}`, 'success');
        } catch (error) {
            console.error('Error importing relationships:', error);
            showNotification('Error importing relationships: ' + error.message, 'danger');
        }
    }
    
    async function deleteRelationship(relationshipId) {
        if (!confirm('Are you sure you want to delete this relationship?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/relationships/${relationshipId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error('Failed to delete relationship');
            }
            
            await loadRelationships();
            showNotification('Relationship deleted successfully', 'success');
        } catch (error) {
            console.error('Error deleting relationship:', error);
            showNotification('Error: ' + error.message, 'danger');
        }
    }
    
    // ========== Hierarchy View Functionality ==========
    let hierarchyLoaded = false;
    
    async function loadHierarchy() {
        console.log(`[Section ${sectionUid}] loadHierarchy called, hierarchyLoaded=${hierarchyLoaded}`);
        if (hierarchyLoaded) return;
        
        const loadingDiv = document.getElementById('hierarchyLoading' + sectionUid);
        const contentDiv = document.getElementById('hierarchyContent' + sectionUid);
        
        console.log(`[Section ${sectionUid}] loadingDiv:`, loadingDiv);
        console.log(`[Section ${sectionUid}] contentDiv:`, contentDiv);
        
        if (!loadingDiv || !contentDiv) {
            console.error(`[Section ${sectionUid}] Missing hierarchy DOM elements!`);
            return;
        }
        
        loadingDiv.style.display = 'flex';
        contentDiv.innerHTML = '';
        
        try {
            console.log(`[Section ${sectionUid}] Fetching hierarchy from /api/entries/${entryId}/relationships/hierarchy`);
            const response = await fetch(`/api/entries/${entryId}/relationships/hierarchy`);
            const data = await response.json();
            
            if (!response.ok) {
                throw new Error(data.error || 'Failed to load hierarchy');
            }
            
            const hierarchy = data.hierarchy || [];
            renderHierarchyTree(hierarchy, contentDiv);
            hierarchyLoaded = true;
            
        } catch (error) {
            console.error('Error loading hierarchy:', error);
            contentDiv.innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    Error loading hierarchy: ${escapeHtml(error.message)}
                    <button class="btn btn-sm btn-outline-danger ms-3" onclick="retryLoadHierarchy${sectionUid}()">
                        <i class="fas fa-redo me-1"></i>Retry
                    </button>
                </div>
            `;
        } finally {
            loadingDiv.style.display = 'none';
        }
    }
    
    function renderHierarchyTree(hierarchy, container) {
        console.log('renderHierarchyTree called with:', hierarchy);
        
        if (!hierarchy || hierarchy.length === 0) {
            container.innerHTML = `
                <div class="hierarchy-empty-state">
                    <i class="fas fa-sitemap"></i>
                    <p class="text-muted">No hierarchical relationships found</p>
                    <small class="text-muted d-block mb-2">Parent-child relationships will appear here</small>
                    <a href="/manage_relationships" class="btn btn-sm btn-outline-primary">
                        <i class="fas fa-cog me-1"></i>Configure Relationship Definitions
                    </a>
                </div>
            `;
            return;
        }
        
        // Build HTML for each relationship type tree
        let treeHtml = '';
        if (hierarchy.length > 1) {
            // Multiple relationship types - show separate trees with headers
            treeHtml = hierarchy.map((rootNode, index) => {
                const relationshipTypeName = rootNode.relationship_type_name || `Relationship ${index + 1}`;
                const treeContent = renderTreeNode(rootNode, 0);
                return `
                    <div class="relationship-tree-section mb-4">
                        <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                            <h6 class="text-primary mb-0">
                                <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                            </h6>
                        </div>
                        <div class="relationship-tree">${treeContent}</div>
                    </div>
                `;
            }).join('<hr class="my-3">');
        } else {
            // Single relationship type tree
            const rootNode = hierarchy[0];
            const relationshipTypeName = rootNode.relationship_type_name;
            const headerHtml = relationshipTypeName ? `
                <div class="tree-header mb-3 p-2" style="background-color: var(--bs-light); border-left: 3px solid var(--bs-primary); border-radius: 0.25rem;">
                    <h6 class="text-primary mb-0">
                        <i class="fas fa-sitemap me-2"></i>${escapeHtml(relationshipTypeName)}
                    </h6>
                </div>
            ` : '';
            treeHtml = `${headerHtml}<div class="relationship-tree">${renderTreeNode(rootNode, 0)}</div>`;
        }
        
        container.innerHTML = treeHtml;
        
        // Initialize tree toggles after rendering
        initializeTreeToggles();
    }
    
    function renderTreeNode(node, level) {
        const isTarget = node.is_target || false;  // The entry we're viewing
        const hasChildren = node.children && node.children.length > 0;
        
        const nodeClasses = ['tree-node-content'];
        if (isTarget) nodeClasses.push('current-entry');
        
        let html = `
            <div class="tree-node level-${level}" data-entry-id="${node.id}" style="padding-left: ${level * 20}px;">
                <div class="${nodeClasses.join(' ')}">
        `;
        
        // Toggle button or spacer
        if (hasChildren) {
            html += `
                <button class="tree-toggle-btn" data-node-id="${node.id}">
                    <i class="fas fa-chevron-down"></i>
                </button>
            `;
        } else {
            html += `<span class="tree-spacer"></span>`;
        }
        
        // Entry type icon
        html += `
            <span class="tree-entry-type" 
                  style="color: ${node.entry_type.color || '#6c757d'};"
                  title="${escapeHtml(node.entry_type.label)}">
                <i class="${node.entry_type.icon || 'fas fa-link'}"></i>
            </span>
        `;
        
        // Direction indicator (parent/child arrow)
        const direction = node.direction || 'unknown';
        if (direction === 'ancestor') {
            html += `
                <span class="tree-direction-icon" title="Parent/Ancestor">
                    <i class="fas fa-arrow-up text-primary"></i>
                </span>
            `;
        } else if (direction === 'descendant') {
            html += `
                <span class="tree-direction-icon" title="Child/Descendant">
                    <i class="fas fa-arrow-down text-success"></i>
                </span>
            `;
        }
        
        // Entry title and link
        html += `
            <a href="/entry/${node.id}" 
               class="tree-entry-link ${isTarget ? 'fw-bold' : ''}"
               target="_blank">
                ${escapeHtml(node.title)}
        `;
        
        // Badge for current/target entry
        if (isTarget) {
            html += `<span class="badge bg-success ms-2">Current</span>`;
        }
        html += `</a>`;
        
        // Status badge with dynamic color
        if (node.status) {
            const statusColor = node.status_color || '#6c757d';
            const textColor = getContrastColor(statusColor);
            html += `
                <span class="badge ms-2" style="background-color: ${statusColor}; color: ${textColor};">
                    ${escapeHtml(node.status)}
                </span>
            `;
        }
        
        // Relationship type label
        if (node.relationship_type) {
            html += `
                <small class="text-muted ms-2">
                    <i class="fas fa-link"></i> ${escapeHtml(node.relationship_type)}
                </small>
            `;
        }
        
        html += `</div>`; // Close tree-node-content
        
        // Children (recursive)
        if (hasChildren) {
            html += `<div class="tree-children" data-parent-id="${node.id}">`;
            for (const child of node.children) {
                html += renderTreeNode(child, level + 1);
            }
            html += `</div>`;
        }
        
        html += `</div>`; // Close tree-node
        
        return html;
    }
    
    function initializeTreeToggles() {
        const toggleButtons = document.querySelectorAll('.tree-toggle-btn');
        
        toggleButtons.forEach(button => {
            // Remove existing listeners by cloning
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            newButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const nodeId = this.dataset.nodeId;
                const childrenDiv = document.querySelector(`.tree-children[data-parent-id="${nodeId}"]`);
                const icon = this.querySelector('i');
                
                if (childrenDiv) {
                    childrenDiv.classList.toggle('collapsed');
                    
                    if (childrenDiv.classList.contains('collapsed')) {
                        icon.style.transform = 'rotate(-90deg)';
                    } else {
                        icon.style.transform = 'rotate(0deg)';
                    }
                }
            });
        });
    }
    
    // Retry function for hierarchy loading
    window['retryLoadHierarchy' + sectionUid] = function() {
        hierarchyLoaded = false;
        loadHierarchy();
    };
    
    // Setup tab event listeners
    function setupTabListeners() {
        const hierarchyTab = document.getElementById('hierarchyTab' + sectionUid + '-tab');
        
        console.log(`[Section ${sectionUid}] Setting up tab listeners, hierarchyTab:`, hierarchyTab);
        
        if (hierarchyTab) {
            hierarchyTab.addEventListener('shown.bs.tab', function() {
                console.log(`[Section ${sectionUid}] Hierarchy tab shown event triggered!`);
                loadHierarchy();
            });
            console.log(`[Section ${sectionUid}] Hierarchy tab listener added successfully`);
        } else {
            console.error(`[Section ${sectionUid}] Hierarchy tab button not found!`);
        }
    }
    
    // ========== Note Binding Functions ==========
    
    // Load note binding state from database
    async function loadNoteBindingState() {
        try {
            const response = await fetch(`/api/note_bindings?entry_id=${entryId}`);
            if (response.ok) {
                const bindings = await response.json();
                noteBingingState.clear();
                bindings.forEach(binding => {
                    if (binding.enabled) {
                        noteBingingState.set(binding.target_entry_id, true);
                    }
                });
                noteBingingState.forEach((isEnabled, entryId) => {
                    updateBindNotesButtonState(entryId, isEnabled);
                });
                console.log('[Note Binding] Loaded state:', noteBingingState);
            }
        } catch (error) {
            console.error('[Note Binding] Error loading state:', error);
        }
    }
    
    // Show Bind Notes Modal
    function showBindNotesModal(targetEntryId, targetEntryTitle) {
        const modalId = 'bindNotesModal_' + sectionUid;
        const existingModal = document.getElementById(modalId);
        if (existingModal) existingModal.remove();
        
        const currentBindingState = noteBingingState.get(parseInt(targetEntryId)) || false;
        
        const modalHtml = `
            <div class="modal fade" id="${modalId}" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title"><i class="fas fa-link me-2"></i>Bind Notes: ${escapeHtml(targetEntryTitle)}</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="alert alert-info">
                                <i class="fas fa-info-circle me-2"></i>
                                <strong>Note Binding:</strong> When enabled, new notes in this entry will automatically be associated with <strong>${escapeHtml(targetEntryTitle)}</strong>.
                            </div>
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="bindNotesToggle_${modalId}" ${currentBindingState ? 'checked' : ''}>
                                <label class="form-check-label" for="bindNotesToggle_${modalId}">
                                    <strong>Enable automatic note binding</strong>
                                </label>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                            <button type="button" class="btn btn-primary" id="saveBindingBtn_${modalId}">
                                <i class="fas fa-save me-1"></i>Save
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = new bootstrap.Modal(document.getElementById(modalId));
        modal.show();
        
        document.getElementById('saveBindingBtn_' + modalId).addEventListener('click', async function() {
            const isEnabled = document.getElementById('bindNotesToggle_' + modalId).checked;
            try {
                this.disabled = true;
                this.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving...';
                
                const response = await fetch('/api/note_bindings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_entry_id: entryId,
                        target_entry_id: parseInt(targetEntryId),
                        enabled: isEnabled
                    })
                });
                
                if (response.ok) {
                    noteBingingState.set(parseInt(targetEntryId), isEnabled);
                    updateBindNotesButtonState(targetEntryId, isEnabled);
                    showNotification(`Note binding ${isEnabled ? 'enabled' : 'disabled'}`, 'success');
                    modal.hide();
                } else {
                    throw new Error('Failed to save');
                }
            } catch (error) {
                showNotification('Error saving: ' + error.message, 'danger');
            }
        });
        
        document.getElementById(modalId).addEventListener('hidden.bs.modal', function() { this.remove(); });
    }
    
    // Update bind notes button visual state
    function updateBindNotesButtonState(targetEntryId, isEnabled) {
        const container = document.getElementById('groupedViewContainer' + sectionUid);
        if (!container) return;
        
        const button = container.querySelector(`[data-entry-id="${targetEntryId}"].btn-bind-notes`);
        if (button) {
            if (isEnabled) {
                button.classList.remove('btn-outline-primary');
                button.classList.add('btn-primary');
                button.title = 'Notes binding enabled - click to configure';
            } else {
                button.classList.remove('btn-primary');
                button.classList.add('btn-outline-primary');
                button.title = 'Bind notes from this entry';
            }
        }
    }
    
    // Initialize tab listeners
    console.log(`[Section ${sectionUid}] Initializing relationships section...`);
    setupTabListeners();
    
    // Load note binding state after a short delay to ensure DOM is ready
    setTimeout(() => loadNoteBindingState(), 500);
    
})();
</script>
