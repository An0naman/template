{# Header Section - Entry title, details, and description #}

<div class="d-flex flex-column flex-lg-row justify-content-between align-items-start gap-3 mb-4">
    <!-- Entry Title -->
    <div class="flex-grow-1">
        <h1 class="h1 mb-0" id="entryTitle">{{ entry.title }}</h1>
        <input type="text" class="form-control form-control-lg d-none" id="entryTitleInput" value="{{ entry.title }}" placeholder="Enter entry title">
    </div>
    
    <!-- Action Buttons Group -->
    <div class="d-flex flex-wrap gap-2 align-items-start">
        <!-- Edit Mode Buttons (Hidden by default) -->
        <button type="button" class="btn btn-sm btn-success d-none" id="saveEntryBtn" style="display: none !important;">
            <i class="fas fa-save me-1"></i>Save
        </button>
        <button type="button" class="btn btn-sm btn-secondary d-none" id="cancelEditBtn" style="display: none !important;">
            <i class="fas fa-times me-1"></i>Cancel
        </button>
        
        <!-- Primary Actions -->
        <div class="btn-group" role="group" aria-label="Entry actions">
            <button type="button" class="btn btn-sm btn-outline-primary" id="editEntryBtn">
                <i class="fas fa-edit me-1"></i>Edit
            </button>
            <button type="button" class="btn btn-sm btn-outline-danger" id="deleteEntryBtn">
                <i class="fas fa-trash me-1"></i>Delete
            </button>
        </div>
        
        <!-- Section Toggle Buttons -->
        <div class="btn-group" role="group" aria-label="Section toggles">
            {% if collapsible_sections is defined %}
                {% for sect in collapsible_sections %}
                    <button type="button" 
                            class="btn btn-sm section-toggle-btn {{ 'section-hidden' if sect.default_collapsed else 'section-visible' }}"
                            onclick="toggleSection({{ sect.id }}, '{{ sect.tab_id }}')"
                            data-section-id="{{ sect.id }}"
                            data-section-type="{{ sect.type }}"
                            data-tab-id="{{ sect.tab_id }}"
                            title="Toggle {{ sect.title or sect.type.replace('_', ' ').title() }}">
                        <i class="fas {{ 'fa-eye-slash' if sect.default_collapsed else 'fa-eye' }} me-1"></i>{{ sect.title or sect.type.replace('_', ' ').title() }}
                    </button>
                {% endfor %}
            {% endif %}
        </div>
    </div>
</div>

<div class="row g-3">
    <div class="col-md-4">
        <div class="info-card">
            <div class="info-label">Details</div>
            <div class="info-value">
                <!-- Display Mode -->
                <div id="detailsDisplay">
                    <div><strong>Type:</strong> <span id="entryTypeDisplay">{{ entry.entry_type_label }}</span></div>
                    <div><strong>Status:</strong> 
                        <span class="badge" style="background-color: {{ entry.status_color }}; color: white;" id="statusDisplay">
                            {{ (entry.status or 'Active').title() }}
                        </span>
                    </div>
                </div>
                <!-- Edit Mode -->
                <div id="detailsEdit" class="d-none">
                    <div class="mb-2">
                        <label for="entryTypeSelect" class="form-label small">Entry Type</label>
                        <select class="form-select form-select-sm" id="entryTypeSelect">
                            <!-- Options will be loaded dynamically -->
                        </select>
                    </div>
                    <div class="mb-2">
                        <label for="statusSelect" class="form-label small">Status</label>
                        <select class="form-select form-select-sm" id="statusSelect">
                            <option value="active" {{ 'selected' if entry.status == 'active' else '' }}>Active</option>
                            <option value="inactive" {{ 'selected' if entry.status == 'inactive' else '' }}>Inactive</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-md-8">
        <div class="info-card">
            <div class="info-label">Dates</div>
            <div class="info-value">
                <!-- Display Mode -->
                <div id="datesDisplay">
                    <div class="mb-2">
                        <strong>Created On:</strong><br class="d-md-none">
                        <span class="ms-md-2" id="created-at">{{ entry.created_at }}</span>
                    </div>
                    {% if entry.commenced_at %}
                    <div class="mb-2">
                        <strong>Commenced:</strong><br class="d-md-none">
                        <span class="ms-md-2" id="commenced-at-display">{{ entry.commenced_at[:10] if entry.commenced_at else '' }}</span>
                    </div>
                    {% endif %}
                    {% if entry.intended_end_date and entry.show_end_dates %}
                    <div class="mb-2">
                        <strong>Intended End:</strong><br class="d-md-none">
                        <span class="ms-md-2" id="intended-end-date-display">{{ entry.intended_end_date[:10] if entry.intended_end_date else '' }}</span>
                    </div>
                    {% endif %}
                    {% if entry.actual_end_date and entry.show_end_dates %}
                    <div class="mb-2">
                        <strong>Actual End:</strong><br class="d-md-none">
                        <span class="ms-md-2" id="actual-end-date-display">{{ entry.actual_end_date[:10] if entry.actual_end_date else '' }}</span>
                    </div>
                    {% endif %}
                </div>
                <!-- Edit Mode -->
                {% if entry.show_end_dates %}
                <div id="datesEdit" class="d-none">
                    <div class="mb-2">
                        <strong>Created On:</strong><br class="d-md-none">
                        <span class="ms-md-2 text-muted" id="created-at-edit">{{ entry.created_at }}</span>
                    </div>
                    <div class="mb-2">
                        <label for="commencedAtInput" class="form-label small">Commenced Date</label>
                        <input type="date" class="form-control form-control-sm" id="commencedAtInput" value="{{ entry.commenced_at[:10] if entry.commenced_at else '' }}">
                        <small class="text-muted">Start date for milestone calculations</small>
                    </div>
                    <div class="mb-2">
                        <label for="intendedEndDateInput" class="form-label small">Intended End Date</label>
                        <input type="date" class="form-control form-control-sm" id="intendedEndDateInput" value="{{ entry.intended_end_date[:10] if entry.intended_end_date else '' }}">
                    </div>
                    <div class="mb-2">
                        <label for="actualEndDateInput" class="form-label small">Actual End Date</label>
                        <input type="date" class="form-control form-control-sm" id="actualEndDateInput" value="{{ entry.actual_end_date[:10] if entry.actual_end_date else '' }}">
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<div class="mt-3">
    <div class="info-card">
        <div class="info-label">Description</div>
        <div class="info-value">
            <!-- Display Mode -->
            <div id="descriptionDisplay" class="markdown-content">{{ entry.description or 'No description available' }}</div>
            <!-- Edit Mode -->
            <div id="descriptionEdit" class="d-none">
                <textarea class="form-control" id="descriptionTextarea" rows="4" placeholder="Add a detailed description for this entry...">{{ entry.description if entry.description is not none else '' }}</textarea>
            </div>
        </div>
    </div>
</div>

<style>
/* Mobile-specific header adjustments */
@media (max-width: 991.98px) {
    /* Don't stack button groups - let them wrap naturally */
    .btn-group {
        display: inline-flex;
    }
    
    .btn-group > .btn,
    .btn-group > .btn-sm {
        font-size: 0.875rem;
    }
    
    /* Make title smaller on mobile */
    .h1 {
        font-size: 1.75rem;
    }
    
    /* Stack info cards vertically on mobile */
    .col-md-4,
    .col-md-8 {
        width: 100%;
    }
}

/* Very small screens - make toggle buttons more compact */
@media (max-width: 575.98px) {
    .section-toggle-btn {
        font-size: 0.75rem;
        padding: 0.375rem 0.5rem;
    }
}

/* Section toggle button styles - theme-aware */
.section-toggle-btn {
    border: 1px solid var(--theme-info, var(--bs-info));
    color: var(--theme-info, var(--bs-info));
    background-color: transparent;
    transition: all 0.2s ease;
}

.section-toggle-btn:hover {
    background-color: var(--theme-info-subtle, rgba(13, 202, 240, 0.1));
    border-color: var(--theme-info-hover, var(--theme-info, var(--bs-info)));
}

.section-toggle-btn.section-visible {
    background-color: var(--theme-info, var(--bs-info));
    color: white;
    border-color: var(--theme-info, var(--bs-info));
}

.section-toggle-btn.section-visible:hover {
    background-color: var(--theme-info-hover, var(--theme-info, var(--bs-info)));
    filter: brightness(1.1);
}

.section-toggle-btn.section-hidden {
    background-color: transparent;
    border-color: var(--theme-secondary, var(--bs-secondary));
    color: var(--theme-text-muted, var(--bs-secondary));
}

.section-toggle-btn.section-hidden:hover {
    background-color: var(--theme-secondary-subtle, rgba(108, 117, 125, 0.1));
    border-color: var(--theme-secondary-hover, var(--theme-secondary, var(--bs-secondary)));
}
</style>

<script>
// Use the global entryId if available, otherwise extract from template
// Use var instead of const to allow redeclaration if needed
var entryId = window.currentPageEntryId || {{ entry.id }};
const originalEntryTypeId = {{ entry.entry_type_id }};
var isEditing = false;

// DOM elements
const entryTitleDisplay = document.getElementById('entryTitle');
const entryTitleInput = document.getElementById('entryTitleInput');
const detailsDisplay = document.getElementById('detailsDisplay');
const detailsEdit = document.getElementById('detailsEdit');
const datesDisplay = document.getElementById('datesDisplay');
const datesEdit = document.getElementById('datesEdit');
const descriptionDisplay = document.getElementById('descriptionDisplay');
const descriptionEdit = document.getElementById('descriptionEdit');
const entryTypeSelect = document.getElementById('entryTypeSelect');
const statusSelect = document.getElementById('statusSelect');
const descriptionTextarea = document.getElementById('descriptionTextarea');
{% if entry.show_end_dates %}
const intendedEndDateInput = document.getElementById('intendedEndDateInput');
const actualEndDateInput = document.getElementById('actualEndDateInput');
const commencedAtInput = document.getElementById('commencedAtInput');
{% endif %}

// Original values for cancel
const originalValues = {
    title: {{ entry.title|tojson }},
    description: {{ (entry.description if entry.description is not none else "")|tojson }},
    entryTypeId: originalEntryTypeId,
    status: {{ (entry.status if entry.status else "active")|tojson }},
    {% if entry.show_end_dates %}
    intendedEndDate: '{{ entry.intended_end_date[:10] if entry.intended_end_date else "" }}',
    actualEndDate: '{{ entry.actual_end_date[:10] if entry.actual_end_date else "" }}',
    commencedAt: '{{ entry.commenced_at[:10] if entry.commenced_at else "" }}'
    {% endif %}
};

// Toggle edit mode
function toggleEditMode(editing) {
    isEditing = editing;
    
    if (editing) {
        // Show edit elements, hide display elements
        if (entryTitleDisplay) entryTitleDisplay.classList.add('d-none');
        if (entryTitleInput) entryTitleInput.classList.remove('d-none');
        if (detailsDisplay) detailsDisplay.classList.add('d-none');
        if (detailsEdit) detailsEdit.classList.remove('d-none');
        {% if entry.show_end_dates %}
        if (datesDisplay) datesDisplay.classList.add('d-none');
        if (datesEdit) datesEdit.classList.remove('d-none');
        {% endif %}
        if (descriptionDisplay) descriptionDisplay.classList.add('d-none');
        if (descriptionEdit) descriptionEdit.classList.remove('d-none');
        
        // Show save/cancel buttons, hide other buttons
        const saveBtn = document.getElementById('saveEntryBtn');
        const cancelBtn = document.getElementById('cancelEditBtn');
        if (saveBtn) {
            saveBtn.classList.remove('d-none');
            saveBtn.style.display = '';
        }
        if (cancelBtn) {
            cancelBtn.classList.remove('d-none');
            cancelBtn.style.display = '';
        }
        
        const editBtn = document.getElementById('editEntryBtn');
        const deleteBtn = document.getElementById('deleteEntryBtn');
        const backBtn = document.getElementById('backBtn');
        if (editBtn) editBtn.classList.add('d-none');
        if (deleteBtn) deleteBtn.classList.add('d-none');
        if (backBtn) backBtn.classList.add('d-none');
        
        // Load entry types
        loadEntryTypes();
    } else {
        // Show display elements, hide edit elements
        if (entryTitleDisplay) entryTitleDisplay.classList.remove('d-none');
        if (entryTitleInput) entryTitleInput.classList.add('d-none');
        if (detailsDisplay) detailsDisplay.classList.remove('d-none');
        if (detailsEdit) detailsEdit.classList.add('d-none');
        {% if entry.show_end_dates %}
        if (datesDisplay) datesDisplay.classList.remove('d-none');
        if (datesEdit) datesEdit.classList.add('d-none');
        {% endif %}
        if (descriptionDisplay) descriptionDisplay.classList.remove('d-none');
        if (descriptionEdit) descriptionEdit.classList.add('d-none');
        
        // Show other buttons, hide save/cancel buttons
        const saveBtn = document.getElementById('saveEntryBtn');
        const cancelBtn = document.getElementById('cancelEditBtn');
        if (saveBtn) {
            saveBtn.classList.add('d-none');
            saveBtn.style.display = 'none';
        }
        if (cancelBtn) {
            cancelBtn.classList.add('d-none');
            cancelBtn.style.display = 'none';
        }
        
        const editBtn = document.getElementById('editEntryBtn');
        const deleteBtn = document.getElementById('deleteEntryBtn');
        const backBtn = document.getElementById('backBtn');
        if (editBtn) editBtn.classList.remove('d-none');
        if (deleteBtn) deleteBtn.classList.remove('d-none');
        if (backBtn) backBtn.classList.remove('d-none');
    }
}

// Load entry types for the select dropdown
async function loadEntryTypes() {
    try {
        const response = await fetch('/api/entry_types');
        if (!response.ok) {
            throw new Error(`Failed to load entry types: ${response.status} ${response.statusText}`);
        }
        const entryTypes = await response.json();
        
        if (!entryTypes || entryTypes.length === 0) {
            console.error('[Entry Edit] No entry types returned from API');
            alert('Failed to load entry types. Please refresh the page.');
            return;
        }
        
        console.log('[Entry Edit] Loading entry types. Original entry type ID:', originalEntryTypeId);
        console.log('[Entry Edit] Available entry types:', entryTypes);
        
        entryTypeSelect.innerHTML = '';
        let foundMatch = false;
        entryTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type.id;
            option.textContent = type.singular_label;
            if (type.id == originalEntryTypeId) {
                option.selected = true;
                foundMatch = true;
                console.log('[Entry Edit] Selected entry type:', type.singular_label, 'with ID:', type.id);
            }
            entryTypeSelect.appendChild(option);
        });
        
        if (!foundMatch) {
            console.warn('[Entry Edit] Original entry type ID not found in available types:', originalEntryTypeId);
        }
        
        console.log('[Entry Edit] Entry type select value after loading:', entryTypeSelect.value);
        console.log('[Entry Edit] Selected index:', entryTypeSelect.selectedIndex);
        
        // Load states for the current entry type
        await loadStatesForEntry();
    } catch (error) {
        console.error('[Entry Edit] Error loading entry types:', error);
        alert('Failed to load entry types. Please refresh the page and try again.');
    }
}

// Load available states for the current entry
async function loadStatesForEntry() {
    try {
        const response = await fetch(`/api/entries/{{ entry.id }}/available_states`);
        const states = await response.json();
        
        // Store the current status before clearing the dropdown
        // Only use statusSelect.value if it's a valid state name (not the hardcoded active/inactive placeholders)
        // Check if current value exists in the states we're about to load
        const hasValidStatus = statusSelect.value && states.some(s => s.name === statusSelect.value);
        const currentStatus = hasValidStatus ? statusSelect.value : (originalValues.status || '{{ entry.status }}');
        statusSelect.innerHTML = '';
        
        // Group states by category
        const activeStates = states.filter(s => s.category === 'active');
        const inactiveStates = states.filter(s => s.category === 'inactive');
        
        // Add active states
        if (activeStates.length > 0) {
            const activeGroup = document.createElement('optgroup');
            activeGroup.label = '✓ Active (Ongoing)';
            activeStates.forEach(state => {
                const option = document.createElement('option');
                option.value = state.name;
                option.textContent = state.name;
                option.dataset.category = state.category;
                option.dataset.color = state.color;
                if (state.name.toLowerCase() === currentStatus.toLowerCase()) {
                    option.selected = true;
                }
                activeGroup.appendChild(option);
            });
            statusSelect.appendChild(activeGroup);
        }
        
        // Add inactive states
        if (inactiveStates.length > 0) {
            const inactiveGroup = document.createElement('optgroup');
            inactiveGroup.label = '✕ Inactive (Completed)';
            inactiveStates.forEach(state => {
                const option = document.createElement('option');
                option.value = state.name;
                option.textContent = state.name;
                option.dataset.category = state.category;
                option.dataset.color = state.color;
                if (state.name.toLowerCase() === currentStatus.toLowerCase()) {
                    option.selected = true;
                }
                inactiveGroup.appendChild(option);
            });
            statusSelect.appendChild(inactiveGroup);
        }
    } catch (error) {
        console.error('Error loading states:', error);
        // Fallback to default options
        statusSelect.innerHTML = `
            <optgroup label="✓ Active (Ongoing)">
                <option value="Active">Active</option>
            </optgroup>
            <optgroup label="✕ Inactive (Completed)">
                <option value="Inactive">Inactive</option>
            </optgroup>
        `;
    }
}

// Listen for entry type changes to update available states
entryTypeSelect.addEventListener('change', loadStatesForEntry);

// Edit Entry functionality
document.getElementById('editEntryBtn')?.addEventListener('click', function() {
    toggleEditMode(true);
});

document.getElementById('cancelEditBtn')?.addEventListener('click', function() {
    // Reset values
    entryTitleInput.value = originalValues.title;
    descriptionTextarea.value = originalValues.description;
    statusSelect.value = originalValues.status;
    {% if entry.show_end_dates %}
    if (intendedEndDateInput) intendedEndDateInput.value = originalValues.intendedEndDate;
    if (actualEndDateInput) actualEndDateInput.value = originalValues.actualEndDate;
    if (commencedAtInput) commencedAtInput.value = originalValues.commencedAt;
    {% endif %}
    
    toggleEditMode(false);
});

document.getElementById('saveEntryBtn')?.addEventListener('click', async function() {
    const newTitle = entryTitleInput.value.trim();
    const description = descriptionTextarea.value;
    const entryTypeId = parseInt(entryTypeSelect.value);
    const status = statusSelect.value;
    {% if entry.show_end_dates %}
    const intendedEndDate = intendedEndDateInput ? intendedEndDateInput.value : null;
    const actualEndDate = actualEndDateInput ? actualEndDateInput.value : null;
    const commencedAt = commencedAtInput ? commencedAtInput.value : null;
    {% else %}
    const intendedEndDate = null;
    const actualEndDate = null;
    const commencedAt = null;
    {% endif %}
    
    if (!newTitle) {
        alert('Title cannot be empty');
        return;
    }
    
    if (!entryTypeId || isNaN(entryTypeId)) {
        console.error('[Entry Save] Invalid entry type ID:', entryTypeId);
        alert('Please select a valid entry type');
        return;
    }
    
    console.log('[Entry Save] Saving with entry type ID:', entryTypeId);
    console.log('[Entry Save] Entry type select value:', entryTypeSelect.value);
    console.log('[Entry Save] Entry type selected index:', entryTypeSelect.selectedIndex);
    
    // Show loading
    const saveBtn = document.getElementById('saveEntryBtn');
    const originalHTML = saveBtn.innerHTML;
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving...';
    
    const payload = {
        title: newTitle,
        description: description,
        entry_type_id: entryTypeId,
        status: status,
        intended_end_date: intendedEndDate,
        actual_end_date: actualEndDate,
        commenced_at: commencedAt
    };
    
    console.log('[Entry Save] Request payload:', payload);
    
    try {
        const response = await fetch(`/api/entries/{{ entry.id }}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });
        
        if (response.ok) {
            const data = await response.json();
            
            // Update displays
            entryTitleDisplay.textContent = newTitle;
            descriptionDisplay.textContent = description || 'No description available';
            // Re-render markdown
            if (typeof renderMarkdown === 'function') {
                renderMarkdown(descriptionDisplay);
            }
            
            // Update entry type display
            const selectedOption = entryTypeSelect.options[entryTypeSelect.selectedIndex];
            if (selectedOption) {
                document.getElementById('entryTypeDisplay').textContent = selectedOption.textContent;
                console.log('[Entry Save] Updated entry type display to:', selectedOption.textContent);
            } else {
                console.error('[Entry Save] No selected option found in entry type dropdown');
            }
            
            // Update status display with color
            const selectedStatus = statusSelect.options[statusSelect.selectedIndex];
            const statusBadge = document.getElementById('statusDisplay');
            statusBadge.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            if (selectedStatus.dataset.color) {
                statusBadge.style.backgroundColor = selectedStatus.dataset.color;
                statusBadge.style.color = 'white';
            }
            
            {% if entry.show_end_dates %}
            // Update date displays
            if (intendedEndDate && document.getElementById('intended-end-date-display')) {
                document.getElementById('intended-end-date-display').textContent = intendedEndDate;
            }
            if (actualEndDate && document.getElementById('actual-end-date-display')) {
                document.getElementById('actual-end-date-display').textContent = actualEndDate;
            }
            {% endif %}
            
            toggleEditMode(false);
        } else {
            const data = await response.json();
            alert('Failed to update entry: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error:', error);
        alert('An error occurred while updating the entry');
    } finally {
        saveBtn.disabled = false;
        saveBtn.innerHTML = originalHTML;
    }
});

// Delete Entry functionality
document.getElementById('deleteEntryBtn')?.addEventListener('click', function() {
    if (confirm('Are you sure you want to delete this entry? This action cannot be undone.')) {
        fetch(`/api/entries/{{ entry.id }}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => {
            if (response.ok) {
                window.location.href = '/';
            } else {
                alert('Failed to delete entry');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while deleting the entry');
        });
    }
});

// Note: toggleSection function is now defined globally in entry_detail_v2.html

// Format the created_at timestamp to locale string on page load
document.addEventListener('DOMContentLoaded', function() {
    const createdAtSpan = document.getElementById('created-at');
    const createdAtEditSpan = document.getElementById('created-at-edit');
    
    if (createdAtSpan && createdAtSpan.textContent) {
        try {
            const date = new Date(createdAtSpan.textContent);
            createdAtSpan.textContent = date.toLocaleString();
        } catch (e) {
            console.error('Error formatting created_at date:', e);
        }
    }
    
    if (createdAtEditSpan && createdAtEditSpan.textContent) {
        try {
            const date = new Date(createdAtEditSpan.textContent);
            createdAtEditSpan.textContent = date.toLocaleString();
        } catch (e) {
            console.error('Error formatting created_at edit date:', e);
        }
    }
});
</script>
